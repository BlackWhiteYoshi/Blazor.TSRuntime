using Microsoft.CodeAnalysis;
using Microsoft.Extensions.ObjectPool;
using System.Collections.Immutable;
using System.Text;
using TSRuntime.Configs;
using TSRuntime.Parsing;

namespace TSRuntime.Generation;

/// <summary>
/// Builds class TSRuntime.
/// </summary>
public static class ClassBuilder {
    /// <summary>
    /// Builds class TSRuntime.
    /// </summary>
    /// <param name="stringBuilderPool"></param>
    /// <param name="context"></param>
    /// <param name="parameters"></param>
    public static void BuildClass(this ObjectPool<StringBuilder> stringBuilderPool, SourceProductionContext context, (ImmutableArray<TSScript> scriptList, (ImmutableArray<TSModule> moduleList, (Config? config, Diagnostic? error) configOrError) tuple) parameters) {
        if (parameters.tuple.configOrError.error is not null) {
            context.ReportDiagnostic(parameters.tuple.configOrError.error);
            return;
        }

        ImmutableArray<TSScript> scriptList = parameters.scriptList;
        ImmutableArray<TSModule> moduleList = parameters.tuple.moduleList;
        Config config = parameters.tuple.configOrError.config!;

        foreach (Diagnostic error in config.ErrorList)
            context.ReportDiagnostic(error);

        StringBuilder builder = stringBuilderPool.Get();


        // usings, namespace, summary
        builder.Append("""
            // <auto-generated/>
            #pragma warning disable
            #nullable enable annotations


            using System;
            using System.Collections.Generic;
            using System.Threading;
            using System.Threading.Tasks;
            
            namespace Microsoft.JSInterop;

            /// <summary>
            /// <para>An implementation for <see cref="ITSRuntime"/>.</para>
            /// <para>It manages JS-modules: It loads the modules, caches it in an array and disposing releases all modules.</para>
            /// <para>
            /// 
            """);
        switch (moduleList.Length) {
            case 0:
                builder.Append("There are no modules available.");
                break;
            case 1:
                builder.AppendInterpolation($"There is 1 module available: {moduleList[0].Name}");
                break;
            default:
                builder.AppendInterpolation($"There are {moduleList.Length} modules available:");
                foreach (TSModule module in moduleList)
                    builder.AppendInterpolation($"<br />\n/// - {module.Name}");
                break;
        }
        builder.Append($"""

            /// </para>
            /// </summary>
            [System.CodeDom.Compiler.GeneratedCodeAttribute("{AssemblyInfo.NAME}", "{AssemblyInfo.VERSION}")]

            """);

        // head
        builder.Append("public sealed class TSRuntime(IJSRuntime jsRuntime) : ");
        if (!config.ModuleGrouping)
            builder.Append("ITSRuntime, ");
        else {
            foreach (TSModule module in moduleList) {
                config.ModuleGroupingNamePattern.AppendNaming(builder, module.Name);
                builder.Append(", ");
            }
        }
        builder.Append("IDisposable, IAsyncDisposable {\n");


        builder.Append("    private readonly CancellationTokenSource cancellationTokenSource = new();\n");

        // has any function with a callback
        bool hasCallback = false;
        IReadOnlyList<TSFile> callbackCurrentList = null!;
        (int loopIndex, int fileIndex, int functionIndex) firstCallback = (-1, -1, -1);
        for (int i = 0; i < scriptList.Length; i++)
            for (int j = 0; j < scriptList[i].FunctionList.Count; j++)
                if (scriptList[i].FunctionList[j].HasCallback) {
                    hasCallback = true;
                    callbackCurrentList = scriptList;
                    firstCallback = (0, i, j);
                    goto callback_search_end;
                }
        for (int i = 0; i < moduleList.Length; i++)
            for (int j = 0; j < moduleList[i].FunctionList.Count; j++)
                if (moduleList[i].FunctionList[j].HasCallback) {
                    hasCallback = true;
                    callbackCurrentList = moduleList;
                    firstCallback = (1, i, j);
                    goto callback_search_end;
                }
        callback_search_end:

        // callback module
        if (hasCallback) {
            builder.Append('\n');
            builder.Append("    private Task<IJSObjectReference>? callbackModule;\n");

            builder.Append("    private Task<IJSObjectReference> CallbackModule => callbackModule ??= jsRuntime.InvokeAsync<IJSObjectReference>(\"import\", \"data:text/javascript,");
            for (int loopIndex = firstCallback.loopIndex; loopIndex < 2; loopIndex++) { // iterating over 2 lists: scriptList and moduleList
                for (int fileIndex = firstCallback.fileIndex; fileIndex < callbackCurrentList.Count; fileIndex++) {
                    TSFile file = callbackCurrentList[fileIndex];
                    for (int functionIndex = 0; functionIndex < file.FunctionList.Count; functionIndex++) {
                        TSFunction function = file.FunctionList[functionIndex];
                        if (function.HasCallback) {
                            builder.AppendInterpolation($"export function {function.Name}(");

                            // parameters
                            if (loopIndex == 1) // loopIndex == 1 corresponds to callbackCurrentList == moduleList;
                                builder.Append("__module,");
                            builder.Append("__callback");
                            for (int i = 0; i < function.ParameterList.Length; i++)
                                if (function.ParameterList[i].type is not null)
                                    builder.AppendInterpolation($",{function.ParameterList[i].name}");

                            builder.Append("){return ");

                            if (loopIndex == 1) // loopIndex == 1 corresponds to callbackCurrentList == moduleList;
                                builder.Append("__module.");
                            else
                                builder.Append("window.");
                            builder.AppendInterpolation($"{function.Name}(");

                            if (function.ParameterList.Length > 0) {
                                for (int i = 0; i < function.ParameterList.Length; i++) {
                                    if (function.ParameterList[i].type is not null)
                                        builder.Append(function.ParameterList[i].name);
                                    else {
                                        // callback closure
                                        
                                        builder.Append('(');

                                        // parameters
                                        if (function.ParameterList[i].typeCallback.Length > 1) { // last parameter is returnType
                                            for (int j = 0; j < function.ParameterList[i].typeCallback.Length - 1; j++) // last parameter is returnType
                                                builder.AppendInterpolation($"{function.ParameterList[i].typeCallback[j].name},");
                                            builder.Length--; // remove ','
                                        }
                                        
                                        // c# method call
                                        builder.Append(")=>__callback.invokeMethod");
                                        if (function.ParameterList[i].typeCallbackPromise)
                                            builder.Append("Async");

                                        // arguments
                                        builder.AppendInterpolation($"('{function.ParameterList[i].name}'");
                                        for (int j = 0; j < function.ParameterList[i].typeCallback.Length - 1; j++) // last parameter is returnType
                                            builder.AppendInterpolation($",{function.ParameterList[i].typeCallback[j].name}");

                                        builder.Append(')');
                                    }

                                    builder.Append(',');
                                }

                                builder.Length--; // remove ','
                            }

                            builder.Append(");}");
                        }
                    }
                }

                callbackCurrentList = moduleList;
            }

            builder.Append("\").AsTask();\n");
        }

        builder.Append('\n');

        // LoadModules()
        foreach (TSModule module in moduleList) {
            builder.Append("    Task<IJSObjectReference> ");
            if (!config.ModuleGrouping)
                builder.Append("ITSRuntime");
            else
                config.ModuleGroupingNamePattern.AppendNaming(builder, module.Name);
            builder.AppendInterpolation($$"""
                .Get{{module.Name}}Module() => Get{{module.Name}}Module();
                    private Task<IJSObjectReference>? {{module.Name}}Module;
                    private Task<IJSObjectReference> Get{{module.Name}}Module()
                        => {{module.Name}}Module switch {
                            Task<IJSObjectReference> { IsCompletedSuccessfully: true }
                            or Task<IJSObjectReference> { IsCompleted: false } => {{module.Name}}Module,
                            _ => {{module.Name}}Module = jsRuntime.InvokeAsync<IJSObjectReference>("import", cancellationTokenSource.Token, "{{module.URLPath}}").AsTask()
                        };


                """);
        }

        // PreloadAllModules()
        {
            builder.AppendInterpolation($"    public Task {config.PreloadAllModulesName}() {{\n");

            if (moduleList.Length > 0) {
                foreach (TSModule module in moduleList)
                    builder.AppendInterpolation($"        Get{module.Name}Module();\n");
                builder.Append('\n');
            }

            builder.Append("        return Task.WhenAll([");
            if (hasCallback)
                builder.Append("CallbackModule, ");
            foreach (TSModule module in moduleList)
                builder.AppendInterpolation($"{module.Name}Module!, ");
            if (builder[^1] is ' ') // if hasCallback or moduleList.Length > 0
                builder.Length -= 2; // remove ", "
            builder.Append("]);\n");

            builder.Append("    }\n\n\n");
        }

        // invoke methods script
        builder.Append("""
                TResult ITSRuntime.TSInvoke<TResult>(string identifier, object?[]? args) => ((IJSInProcessRuntime)jsRuntime).Invoke<TResult>(identifier, args);

                ValueTask<TResult> ITSRuntime.TSInvokeTrySync<TResult>(string identifier, object?[]? args, CancellationToken cancellationToken) {
                    if (jsRuntime is IJSInProcessRuntime jsInProcessRuntime)
                        return ValueTask.FromResult(jsInProcessRuntime.Invoke<TResult>(identifier, args));
                    else
                        return jsRuntime.InvokeAsync<TResult>(identifier, cancellationToken, args);
                }

                ValueTask<TResult> ITSRuntime.TSInvokeAsync<TResult>(string identifier, object?[]? args, CancellationToken cancellationToken)
                    => jsRuntime.InvokeAsync<TResult>(identifier, cancellationToken, args);



            """);
        // invoke methods module
        builder.Append("""
                TResult ITSRuntime.TSInvoke<TResult>(Task<IJSObjectReference> moduleTask, string identifier, object?[]? args) {
                    if (!moduleTask.IsCompletedSuccessfully)
                        throw new JSException("JS-module is not loaded. Use and await the Preload()-method to ensure the module is loaded.");

                    return ((IJSInProcessObjectReference)moduleTask.Result).Invoke<TResult>(identifier, args);
                }

                async ValueTask<TResult> ITSRuntime.TSInvokeTrySync<TResult>(Task<IJSObjectReference> moduleTask, string identifier, object?[]? args, CancellationToken cancellationToken) {
                    IJSObjectReference module = await moduleTask;
                    if (module is IJSInProcessObjectReference inProcessModule)
                        return inProcessModule.Invoke<TResult>(identifier, args);
                    else
                        return await module.InvokeAsync<TResult>(identifier, cancellationToken, args);
                }

                async ValueTask<TResult> ITSRuntime.TSInvokeAsync<TResult>(Task<IJSObjectReference> moduleTask, string identifier, object?[]? args, CancellationToken cancellationToken) {
                    IJSObjectReference module = await moduleTask;
                    return await module.InvokeAsync<TResult>(identifier, cancellationToken, args);
                }

                

            """);
        // invoke methods callback-script
        if (hasCallback)
            builder.Append("""
                    TResult ITSRuntime.TSInvoke<TResult, TCallback>(string identifier, DotNetObjectReference<TCallback> dotNetObjectReference, object?[]? args) where TCallback : class {
                        if (!CallbackModule.IsCompletedSuccessfully)
                            throw new JSException("JS-module is not loaded. Use and await the Preload()-method to ensure the module is loaded.");

                        return ((IJSInProcessObjectReference)CallbackModule.Result).Invoke<TResult>(identifier, [dotNetObjectReference, .. args]);
                    }

                    async ValueTask<TResult> ITSRuntime.TSInvokeTrySync<TResult, TCallback>(string identifier, DotNetObjectReference<TCallback> dotNetObjectReference, object?[]? args, CancellationToken cancellationToken) where TCallback : class {
                        IJSObjectReference module = await CallbackModule;
                        if (module is IJSInProcessObjectReference inProcessModule)
                            return inProcessModule.Invoke<TResult>(identifier, [dotNetObjectReference, .. args]);
                        else
                            return await module.InvokeAsync<TResult>(identifier, cancellationToken, [dotNetObjectReference, .. args]);
                    }

                    async ValueTask<TResult> ITSRuntime.TSInvokeAsync<TResult, TCallback>(string identifier, DotNetObjectReference<TCallback> dotNetObjectReference, object?[]? args, CancellationToken cancellationToken) where TCallback : class {
                        IJSObjectReference module = await CallbackModule;
                        return await module.InvokeAsync<TResult>(identifier, cancellationToken, [dotNetObjectReference, .. args]);
                    }


                
                """);
        else
            builder.Append("""
                    TResult ITSRuntime.TSInvoke<TResult, TCallback>(string identifier, DotNetObjectReference<TCallback> dotNetObjectReference, object?[]? args) where TCallback : class => default; // no callbacks are used

                    ValueTask<TResult> ITSRuntime.TSInvokeTrySync<TResult, TCallback>(string identifier, DotNetObjectReference<TCallback> dotNetObjectReference, object?[]? args, CancellationToken cancellationToken) where TCallback : class => default; // no callbacks are used

                    ValueTask<TResult> ITSRuntime.TSInvokeAsync<TResult, TCallback>(string identifier, DotNetObjectReference<TCallback> dotNetObjectReference, object?[]? args, CancellationToken cancellationToken) where TCallback : class => default; // no callbacks are used



                """);
        // invoke methods callback-module
        if (hasCallback)
            builder.Append("""
                    TResult ITSRuntime.TSInvoke<TResult, TCallback>(Task<IJSObjectReference> moduleTask, string identifier, DotNetObjectReference<TCallback> dotNetObjectReference, object?[]? args) where TCallback : class {
                        if (!moduleTask.IsCompletedSuccessfully || !CallbackModule.IsCompletedSuccessfully)
                            throw new JSException("JS-module is not loaded. Use and await the Preload()-method to ensure the module is loaded.");

                        return ((IJSInProcessObjectReference)CallbackModule.Result).Invoke<TResult>(identifier, [moduleTask.Result, dotNetObjectReference, .. args]);
                    }

                    async ValueTask<TResult> ITSRuntime.TSInvokeTrySync<TResult, TCallback>(Task<IJSObjectReference> moduleTask, string identifier, DotNetObjectReference<TCallback> dotNetObjectReference, object?[]? args, CancellationToken cancellationToken) where TCallback : class {
                        IJSObjectReference module = await CallbackModule;
                        if (module is IJSInProcessObjectReference inProcessModule)
                            return inProcessModule.Invoke<TResult>(identifier, [await moduleTask, dotNetObjectReference, .. args]);
                        else
                            return await module.InvokeAsync<TResult>(identifier, cancellationToken, [await moduleTask, dotNetObjectReference, .. args]);
                    }

                    async ValueTask<TResult> ITSRuntime.TSInvokeAsync<TResult, TCallback>(Task<IJSObjectReference> moduleTask, string identifier, DotNetObjectReference<TCallback> dotNetObjectReference, object?[]? args, CancellationToken cancellationToken) where TCallback : class {
                        IJSObjectReference module = await CallbackModule;
                        return await module.InvokeAsync<TResult>(identifier, cancellationToken, [await moduleTask, dotNetObjectReference, .. args]);
                    }



                """);
        else
            builder.Append("""
                    TResult ITSRuntime.TSInvoke<TResult, TCallback>(Task<IJSObjectReference> moduleTask, string identifier, DotNetObjectReference<TCallback> dotNetObjectReference, object?[]? args) where TCallback : class  => default; // no callbacks are used

                    ValueTask<TResult> ITSRuntime.TSInvokeTrySync<TResult, TCallback>(Task<IJSObjectReference> moduleTask, string identifier, DotNetObjectReference<TCallback> dotNetObjectReference, object?[]? args, CancellationToken cancellationToken) where TCallback : class  => default; // no callbacks are used

                    ValueTask<TResult> ITSRuntime.TSInvokeAsync<TResult, TCallback>(Task<IJSObjectReference> moduleTask, string identifier, DotNetObjectReference<TCallback> dotNetObjectReference, object?[]? args, CancellationToken cancellationToken) where TCallback : class => default; // no callbacks are used



                """);
        builder.Append('\n');

        // BuildClassJsRuntime
        if (config.JSRuntimeSyncEnabled)
            builder.Append("""
                public TResult Invoke<TResult>(string identifier, params object?[]? args)
                    => ((IJSInProcessRuntime)jsRuntime).Invoke<TResult>(identifier, args);


            """);
        if (config.JSRuntimeTrySyncEnabled)
            builder.Append("""
                public ValueTask<TResult> InvokeTrySync<TResult>(string identifier, CancellationToken cancellationToken, params object?[]? args) {
                    if (jsRuntime is IJSInProcessRuntime jsInProcessRuntime)
                        return ValueTask.FromResult(jsInProcessRuntime.Invoke<TResult>(identifier, args));
                    else
                        return jsRuntime.InvokeAsync<TResult>(identifier, cancellationToken, args);
                }


            """);
        if (config.JSRuntimeAsyncEnabled)
            builder.Append("""
                public ValueTask<TResult> InvokeAsync<TResult>(string identifier, CancellationToken cancellationToken, params object?[]? args)
                    => jsRuntime.InvokeAsync<TResult>(identifier, cancellationToken, args);


            """);
        if (builder[^3] is not '\n')
            builder.Append('\n');

        // Dispose
        builder.Append("""
                /// <summary>
                /// Releases each module synchronously if possible, otherwise asynchronously per fire and forget.
                /// </summary>
                public void Dispose() {
                    if (cancellationTokenSource.IsCancellationRequested)
                        return;

                    cancellationTokenSource.Cancel();
                    cancellationTokenSource.Dispose();
            """);
        foreach (TSModule module in moduleList)
            builder.AppendInterpolation($$"""


                        if ({{module.Name}}Module?.IsCompletedSuccessfully == true)
                            if ({{module.Name}}Module.Result is IJSInProcessObjectReference inProcessModule)
                                inProcessModule.Dispose();
                            else
                                _ = {{module.Name}}Module.Result.DisposeAsync().Preserve();
                        {{module.Name}}Module = null;
                """);
        if (hasCallback)
            builder.Append("""


                        if (callbackModule?.IsCompletedSuccessfully == true)
                            if (callbackModule.Result is IJSInProcessObjectReference inProcessModule)
                                inProcessModule.Dispose();
                            else
                                _ = callbackModule.Result.DisposeAsync().Preserve();
                        callbackModule = null;
                """);
        builder.Append("\n    }\n\n");

        // DisposeAsync
        builder.AppendInterpolation($$"""
                /// <summary>
                /// <para>Releases each module synchronously if possible, otherwise asynchronously and returns a task that completes, when all module disposing tasks complete.</para>
                /// <para>The asynchronous disposing tasks are happening in parallel.</para>
                /// </summary>
                /// <returns></returns>
                public ValueTask DisposeAsync() {
                    if (cancellationTokenSource.IsCancellationRequested)
                        return ValueTask.CompletedTask;

                    cancellationTokenSource.Cancel();
                    cancellationTokenSource.Dispose();

                    List<Task> taskList = new({{moduleList.Length}});


            """);
        foreach (TSModule module in moduleList)
            builder.AppendInterpolation($$"""
                        if ({{module.Name}}Module?.IsCompletedSuccessfully == true)
                            if ({{module.Name}}Module.Result is IJSInProcessObjectReference inProcessModule)
                                inProcessModule.Dispose();
                            else {
                                ValueTask valueTask = {{module.Name}}Module.Result.DisposeAsync();
                                if (!valueTask.IsCompleted)
                                    taskList.Add(valueTask.AsTask());
                            }
                        {{module.Name}}Module = null;


                """);
        if (hasCallback)
            builder.Append("""
                        if (callbackModule?.IsCompletedSuccessfully == true)
                            if (callbackModule.Result is IJSInProcessObjectReference inProcessModule)
                                inProcessModule.Dispose();
                            else {
                                ValueTask valueTask = callbackModule.Result.DisposeAsync();
                                if (!valueTask.IsCompleted)
                                    taskList.Add(valueTask.AsTask());
                            }
                        callbackModule = null;


                """);
        builder.Append("""
                    if (taskList.Count == 0)
                        return ValueTask.CompletedTask;
                    else
                        return new ValueTask(Task.WhenAll(taskList));
                }
            }

            """);


        string source = builder.ToString();
        context.AddSource("TSRuntime.g.cs", source);
        stringBuilderPool.Return(builder);
    }
}
