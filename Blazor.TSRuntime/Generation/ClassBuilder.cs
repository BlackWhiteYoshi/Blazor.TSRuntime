using Microsoft.CodeAnalysis;
using Microsoft.Extensions.ObjectPool;
using System.Collections.Immutable;
using System.Text;
using TSRuntime.Configs;
using TSRuntime.Parsing;

namespace TSRuntime.Generation;

/// <summary>
/// Builds class TSRuntime.
/// </summary>
public static class ClassBuilder {
    /// <summary>
    /// Builds class TSRuntime.
    /// </summary>
    /// <param name="stringBuilderPool"></param>
    /// <param name="context"></param>
    /// <param name="parameters"></param>
    public static void BuildClass(this ObjectPool<StringBuilder> stringBuilderPool, SourceProductionContext context, (ImmutableArray<TSScript> scriptList, (ImmutableArray<TSModule> moduleList, (Config? config, Diagnostic? error) configOrError) tuple) parameters) {
        if (parameters.tuple.configOrError.error is not null) {
            context.ReportDiagnostic(parameters.tuple.configOrError.error);
            return;
        }

        ImmutableArray<TSScript> scriptList = parameters.scriptList;
        ImmutableArray<TSModule> moduleList = parameters.tuple.moduleList;
        Config config = parameters.tuple.configOrError.config!;


        foreach (Diagnostic error in config.ErrorList)
            context.ReportDiagnostic(error);


        StringBuilder builder = stringBuilderPool.Get();

        // usings, namespace, summary
        builder.Append("""
            // <auto-generated/>
            #pragma warning disable
            #nullable enable annotations


            using System;
            using System.Collections.Generic;
            using System.Threading;
            using System.Threading.Tasks;
            
            namespace Microsoft.JSInterop;

            /// <summary>
            /// <para>An implementation for <see cref="ITSRuntime"/>.</para>
            /// <para>It manages JS-modules: It loads the modules, caches it in an array and disposing releases all modules.</para>
            /// <para>
            /// 
            """);
        switch (moduleList.Length) {
            case 0:
                builder.Append("There are no modules available.");
                break;
            case 1:
                builder.Append("There is 1 module available: ");
                builder.Append(moduleList[0].Name);
                break;
            default:
                builder.Append("There are ");
                builder.Append(moduleList.Length);
                builder.Append(" modules available:");
                foreach (TSModule module in moduleList) {
                    builder.Append("<br />\n/// - ");
                    builder.Append(module.Name);
                }
                break;
        }
        builder.Append('\n');
        builder.Append("/// </para>\n");
        builder.Append("/// </summary>\n");
        builder.Append($"[System.CodeDom.Compiler.GeneratedCodeAttribute(\"{AssemblyInfo.NAME}\", \"{AssemblyInfo.VERSION}\")]\n");

        // head
        builder.Append("public sealed class TSRuntime(IJSRuntime jsRuntime) : ");
        if (!config.ModuleGrouping)
            builder.Append("ITSRuntime, ");
        else {
            foreach (TSModule module in moduleList) {
                config.ModuleGroupingNamePattern.AppendNaming(builder, module.Name);
                builder.Append(',');
                builder.Append(' ');
            }
        }
        builder.Append("IDisposable, IAsyncDisposable {\n");


        builder.Append("    private readonly CancellationTokenSource cancellationTokenSource = new();\n");

        // has any function with a callback
        bool hasCallback = false;
        IReadOnlyList<TSFile> callbackCurrentList = null!;
        (int loopIndex, int fileIndex, int functionIndex) firstCallback = (-1, -1, -1);
        for (int i = 0; i < scriptList.Length; i++)
            for (int j = 0; j < scriptList[i].FunctionList.Count; j++)
                if (scriptList[i].FunctionList[j].HasCallback) {
                    hasCallback = true;
                    callbackCurrentList = scriptList;
                    firstCallback = (0, i, j);
                    goto callback_search_end;
                }
        for (int i = 0; i < moduleList.Length; i++)
            for (int j = 0; j < moduleList[i].FunctionList.Count; j++)
                if (moduleList[i].FunctionList[j].HasCallback) {
                    hasCallback = true;
                    callbackCurrentList = moduleList;
                    firstCallback = (1, i, j);
                    goto callback_search_end;
                }
        callback_search_end:

        // callback module
        if (hasCallback) {
            builder.Append('\n');
            builder.Append("    private Task<IJSObjectReference>? callbackModule;\n");
            builder.Append("    private Task<IJSObjectReference> CallbackModule => callbackModule ??= jsRuntime.InvokeAsync<IJSObjectReference>(\"import\", \"data:text/javascript,");

            for (int loopIndex = firstCallback.loopIndex; loopIndex < 2; loopIndex++) { // iterating over 2 lists: scriptList and moduleList
                for (int fileIndex = firstCallback.fileIndex; fileIndex < callbackCurrentList.Count; fileIndex++) {
                    TSFile file = callbackCurrentList[fileIndex];
                    for (int functionIndex = 0; functionIndex < file.FunctionList.Count; functionIndex++) {
                        TSFunction function = file.FunctionList[functionIndex];
                        if (function.HasCallback) {
                            builder.Append("export function ");
                            builder.Append(function.Name);
                            // parameters
                            builder.Append("(");
                            if (loopIndex is 1) // loopIndex == 1 corresponds to callbackCurrentList == moduleList;
                                builder.Append("__module,");
                            builder.Append("__callback");
                            for (int i = 0; i < function.ParameterList.Length; i++) {
                                if (function.ParameterList[i].type is not null) {
                                    builder.Append(',');
                                    builder.Append(function.ParameterList[i].name);
                                }
                            }
                            builder.Append("){return ");
                            if (loopIndex == 1) // loopIndex == 1 corresponds to callbackCurrentList == moduleList;
                                builder.Append("__module.");
                            else
                                builder.Append("window.");
                            builder.Append(function.Name);
                            builder.Append('(');
                            if (function.ParameterList.Length > 0) {
                                for (int i = 0; i < function.ParameterList.Length; i++) {
                                    if (function.ParameterList[i].type is not null)
                                        builder.Append(function.ParameterList[i].name);
                                    else {
                                        // callback closure
                                        builder.Append('(');
                                        if (function.ParameterList[i].typeCallback.Length > 1) { // last parameter is returnType
                                            for (int j = 0; j < function.ParameterList[i].typeCallback.Length - 1; j++) { // last parameter is returnType
                                                builder.Append(function.ParameterList[i].typeCallback[j].name);
                                                builder.Append(',');
                                            }
                                            builder.Length--;
                                        }
                                        builder.Append(")=>__callback.invokeMethod");
                                        if (function.ParameterList[i].typeCallbackPromise)
                                            builder.Append("Async");
                                        builder.Append("('");
                                        builder.Append(function.ParameterList[i].name);
                                        builder.Append("'");
                                        for (int j = 0; j < function.ParameterList[i].typeCallback.Length - 1; j++) { // last parameter is returnType
                                            builder.Append(',');
                                            builder.Append(function.ParameterList[i].typeCallback[j].name);
                                        }
                                        builder.Append(')');
                                    }

                                    builder.Append(',');
                                }
                                builder.Length--;
                            }
                            builder.Append(");}");
                        }
                    }
                }

                callbackCurrentList = moduleList;
            }

            builder.Append("\").AsTask();\n");
        }

        builder.Append('\n');

        // LoadModules()
        foreach (TSModule module in moduleList) {
            builder.Append("    Task<IJSObjectReference> ");
            if (!config.ModuleGrouping)
                builder.Append("ITSRuntime");
            else
                config.ModuleGroupingNamePattern.AppendNaming(builder, module.Name);
            builder.Append(".Get");
            builder.Append(module.Name);
            builder.Append("Module() => Get");
            builder.Append(module.Name);
            builder.Append("Module();\n");

            builder.Append("    private Task<IJSObjectReference>? ");
            builder.Append(module.Name);
            builder.Append("Module;\n");

            builder.Append("    private Task<IJSObjectReference> Get");
            builder.Append(module.Name);
            builder.Append("Module()\n");
            builder.Append("        => ");
            builder.Append(module.Name);
            builder.Append("Module switch {\n");
            builder.Append("            Task<IJSObjectReference> { IsCompletedSuccessfully: true }\n");
            builder.Append("            or Task<IJSObjectReference> { IsCompleted: false } => ");
            builder.Append(module.Name);
            builder.Append("Module,\n");
            builder.Append("            _ => ");
            builder.Append(module.Name);
            builder.Append("Module = jsRuntime.InvokeAsync<IJSObjectReference>(\"import\", cancellationTokenSource.Token, \"");
            builder.Append(module.URLPath);
            builder.Append("\").AsTask()\n");
            builder.Append("        };\n\n");
        }

        // PreloadAllModules()
        builder.Append("    public Task ");
        builder.Append(config.PreloadAllModulesName);
        builder.Append("() {\n");
        if (moduleList.Length > 0) {
            foreach (TSModule module in moduleList) {
                builder.Append("        Get");
                builder.Append(module.Name);
                builder.Append("Module();\n");
            }
            builder.Append('\n');
        }
        builder.Append("        return Task.WhenAll([");
        if (hasCallback)
            builder.Append("CallbackModule, ");
        foreach (TSModule module in moduleList) {
            builder.Append(module.Name);
            builder.Append("Module!, ");
        }
        if (builder[^1] is ' ')
            builder.Length -= 2;
        builder.Append("]);\n");
        builder.Append("    }\n\n\n");

        // invoke methods script
        builder.Append("""
                TResult ITSRuntime.TSInvoke<TResult>(string identifier, object?[]? args) => ((IJSInProcessRuntime)jsRuntime).Invoke<TResult>(identifier, args);

                ValueTask<TResult> ITSRuntime.TSInvokeTrySync<TResult>(string identifier, object?[]? args, CancellationToken cancellationToken) {
                    if (jsRuntime is IJSInProcessRuntime jsInProcessRuntime)
                        return ValueTask.FromResult(jsInProcessRuntime.Invoke<TResult>(identifier, args));
                    else
                        return jsRuntime.InvokeAsync<TResult>(identifier, cancellationToken, args);
                }

                ValueTask<TResult> ITSRuntime.TSInvokeAsync<TResult>(string identifier, object?[]? args, CancellationToken cancellationToken)
                    => jsRuntime.InvokeAsync<TResult>(identifier, cancellationToken, args);



            """);
        // invoke methods module
        builder.Append("""
                TResult ITSRuntime.TSInvoke<TResult>(Task<IJSObjectReference> moduleTask, string identifier, object?[]? args) {
                    if (!moduleTask.IsCompletedSuccessfully)
                        throw new JSException("JS-module is not loaded. Use and await the Preload()-method to ensure the module is loaded.");

                    return ((IJSInProcessObjectReference)moduleTask.Result).Invoke<TResult>(identifier, args);
                }

                async ValueTask<TResult> ITSRuntime.TSInvokeTrySync<TResult>(Task<IJSObjectReference> moduleTask, string identifier, object?[]? args, CancellationToken cancellationToken) {
                    IJSObjectReference module = await moduleTask;
                    if (module is IJSInProcessObjectReference inProcessModule)
                        return inProcessModule.Invoke<TResult>(identifier, args);
                    else
                        return await module.InvokeAsync<TResult>(identifier, cancellationToken, args);
                }

                async ValueTask<TResult> ITSRuntime.TSInvokeAsync<TResult>(Task<IJSObjectReference> moduleTask, string identifier, object?[]? args, CancellationToken cancellationToken) {
                    IJSObjectReference module = await moduleTask;
                    return await module.InvokeAsync<TResult>(identifier, cancellationToken, args);
                }

                

            """);
        // invoke methods callback-script
        if (hasCallback)
            builder.Append("""
                    TResult ITSRuntime.TSInvoke<TResult, TCallback>(string identifier, DotNetObjectReference<TCallback> dotNetObjectReference, object?[]? args) where TCallback : class {
                        if (!CallbackModule.IsCompletedSuccessfully)
                            throw new JSException("JS-module is not loaded. Use and await the Preload()-method to ensure the module is loaded.");

                        return ((IJSInProcessObjectReference)CallbackModule.Result).Invoke<TResult>(identifier, [dotNetObjectReference, .. args]);
                    }

                    async ValueTask<TResult> ITSRuntime.TSInvokeTrySync<TResult, TCallback>(string identifier, DotNetObjectReference<TCallback> dotNetObjectReference, object?[]? args, CancellationToken cancellationToken) where TCallback : class {
                        IJSObjectReference module = await CallbackModule;
                        if (module is IJSInProcessObjectReference inProcessModule)
                            return inProcessModule.Invoke<TResult>(identifier, [dotNetObjectReference, .. args]);
                        else
                            return await module.InvokeAsync<TResult>(identifier, cancellationToken, [dotNetObjectReference, .. args]);
                    }

                    async ValueTask<TResult> ITSRuntime.TSInvokeAsync<TResult, TCallback>(string identifier, DotNetObjectReference<TCallback> dotNetObjectReference, object?[]? args, CancellationToken cancellationToken) where TCallback : class {
                        IJSObjectReference module = await CallbackModule;
                        return await module.InvokeAsync<TResult>(identifier, cancellationToken, [dotNetObjectReference, .. args]);
                    }


                
                """);
        else
            builder.Append("""
                    TResult ITSRuntime.TSInvoke<TResult, TCallback>(string identifier, DotNetObjectReference<TCallback> dotNetObjectReference, object?[]? args) where TCallback : class => default; // no callbacks are used

                    ValueTask<TResult> ITSRuntime.TSInvokeTrySync<TResult, TCallback>(string identifier, DotNetObjectReference<TCallback> dotNetObjectReference, object?[]? args, CancellationToken cancellationToken) where TCallback : class => default; // no callbacks are used

                    ValueTask<TResult> ITSRuntime.TSInvokeAsync<TResult, TCallback>(string identifier, DotNetObjectReference<TCallback> dotNetObjectReference, object?[]? args, CancellationToken cancellationToken) where TCallback : class => default; // no callbacks are used



                """);
        // invoke methods callback-module
        if (hasCallback)
            builder.Append("""
                    TResult ITSRuntime.TSInvoke<TResult, TCallback>(Task<IJSObjectReference> moduleTask, string identifier, DotNetObjectReference<TCallback> dotNetObjectReference, object?[]? args) where TCallback : class {
                        if (!moduleTask.IsCompletedSuccessfully || !CallbackModule.IsCompletedSuccessfully)
                            throw new JSException("JS-module is not loaded. Use and await the Preload()-method to ensure the module is loaded.");

                        return ((IJSInProcessObjectReference)CallbackModule.Result).Invoke<TResult>(identifier, [moduleTask.Result, dotNetObjectReference, .. args]);
                    }

                    async ValueTask<TResult> ITSRuntime.TSInvokeTrySync<TResult, TCallback>(Task<IJSObjectReference> moduleTask, string identifier, DotNetObjectReference<TCallback> dotNetObjectReference, object?[]? args, CancellationToken cancellationToken) where TCallback : class {
                        IJSObjectReference module = await CallbackModule;
                        if (module is IJSInProcessObjectReference inProcessModule)
                            return inProcessModule.Invoke<TResult>(identifier, [await moduleTask, dotNetObjectReference, .. args]);
                        else
                            return await module.InvokeAsync<TResult>(identifier, cancellationToken, [await moduleTask, dotNetObjectReference, .. args]);
                    }

                    async ValueTask<TResult> ITSRuntime.TSInvokeAsync<TResult, TCallback>(Task<IJSObjectReference> moduleTask, string identifier, DotNetObjectReference<TCallback> dotNetObjectReference, object?[]? args, CancellationToken cancellationToken) where TCallback : class {
                        IJSObjectReference module = await CallbackModule;
                        return await module.InvokeAsync<TResult>(identifier, cancellationToken, [await moduleTask, dotNetObjectReference, .. args]);
                    }



                """);
        else
            builder.Append("""
                    TResult ITSRuntime.TSInvoke<TResult, TCallback>(Task<IJSObjectReference> moduleTask, string identifier, DotNetObjectReference<TCallback> dotNetObjectReference, object?[]? args) where TCallback : class  => default; // no callbacks are used

                    ValueTask<TResult> ITSRuntime.TSInvokeTrySync<TResult, TCallback>(Task<IJSObjectReference> moduleTask, string identifier, DotNetObjectReference<TCallback> dotNetObjectReference, object?[]? args, CancellationToken cancellationToken) where TCallback : class  => default; // no callbacks are used

                    ValueTask<TResult> ITSRuntime.TSInvokeAsync<TResult, TCallback>(Task<IJSObjectReference> moduleTask, string identifier, DotNetObjectReference<TCallback> dotNetObjectReference, object?[]? args, CancellationToken cancellationToken) where TCallback : class => default; // no callbacks are used



                """);
        builder.Append('\n');

        // BuildClassJsRuntime
        if (config.JSRuntimeSyncEnabled)
            builder.Append("""
                public TResult Invoke<TResult>(string identifier, params object?[]? args)
                    => ((IJSInProcessRuntime)jsRuntime).Invoke<TResult>(identifier, args);


            """);
        if (config.JSRuntimeTrySyncEnabled)
            builder.Append("""
                public ValueTask<TResult> InvokeTrySync<TResult>(string identifier, CancellationToken cancellationToken, params object?[]? args) {
                    if (jsRuntime is IJSInProcessRuntime jsInProcessRuntime)
                        return ValueTask.FromResult(jsInProcessRuntime.Invoke<TResult>(identifier, args));
                    else
                        return jsRuntime.InvokeAsync<TResult>(identifier, cancellationToken, args);
                }


            """);
        if (config.JSRuntimeAsyncEnabled)
            builder.Append("""
                public ValueTask<TResult> InvokeAsync<TResult>(string identifier, CancellationToken cancellationToken, params object?[]? args)
                    => jsRuntime.InvokeAsync<TResult>(identifier, cancellationToken, args);


            """);
        if (builder[^3] is not '\n')
            builder.Append('\n');

        // Dispose
        builder.Append("""
                /// <summary>
                /// Releases each module synchronously if possible, otherwise asynchronously per fire and forget.
                /// </summary>
                public void Dispose() {
                    if (cancellationTokenSource.IsCancellationRequested)
                        return;

                    cancellationTokenSource.Cancel();
                    cancellationTokenSource.Dispose();
            """);
        foreach (TSModule module in moduleList) {
            builder.Append("\n\n");
            builder.Append("        if (");
            builder.Append(module.Name);
            builder.Append("Module?.IsCompletedSuccessfully == true)\n");
            builder.Append("            if (");
            builder.Append(module.Name);
            builder.Append("Module.Result is IJSInProcessObjectReference inProcessModule)\n");
            builder.Append("                inProcessModule.Dispose();\n");
            builder.Append("            else\n");
            builder.Append("                _ = ");
            builder.Append(module.Name);
            builder.Append("Module.Result.DisposeAsync().Preserve();\n");
            builder.Append("        ");
            builder.Append(module.Name);
            builder.Append("Module = null;");
        }
        if (hasCallback)
            builder.Append("""


                        if (callbackModule?.IsCompletedSuccessfully == true)
                            if (callbackModule.Result is IJSInProcessObjectReference inProcessModule)
                                inProcessModule.Dispose();
                            else
                                _ = callbackModule.Result.DisposeAsync().Preserve();
                        callbackModule = null;
                """);
        builder.Append("\n    }\n\n");

        // DisposeAsync
        builder.Append("""
                /// <summary>
                /// <para>Releases each module synchronously if possible, otherwise asynchronously and returns a task that completes, when all module disposing tasks complete.</para>
                /// <para>The asynchronous disposing tasks are happening in parallel.</para>
                /// </summary>
                /// <returns></returns>
                public ValueTask DisposeAsync() {
                    if (cancellationTokenSource.IsCancellationRequested)
                        return ValueTask.CompletedTask;

                    cancellationTokenSource.Cancel();
                    cancellationTokenSource.Dispose();

                    List<Task> taskList = new(
            """);
        builder.Append(moduleList.Length);
        builder.Append(");\n\n");
        foreach (TSModule module in moduleList) {
            builder.Append("        if (");
            builder.Append(module.Name);
            builder.Append("Module?.IsCompletedSuccessfully == true)\n");
            builder.Append("            if (");
            builder.Append(module.Name);
            builder.Append("Module.Result is IJSInProcessObjectReference inProcessModule)\n");
            builder.Append("                inProcessModule.Dispose();\n");
            builder.Append("            else {\n");
            builder.Append("                ValueTask valueTask = ");
            builder.Append(module.Name);
            builder.Append("Module.Result.DisposeAsync();\n");
            builder.Append("                if (!valueTask.IsCompleted)\n");
            builder.Append("                    taskList.Add(valueTask.AsTask());\n");
            builder.Append("            }\n");
            builder.Append("        ");
            builder.Append(module.Name);
            builder.Append("Module = null;\n\n");
        }
        if (hasCallback)
            builder.Append("""
                        if (callbackModule?.IsCompletedSuccessfully == true)
                            if (callbackModule.Result is IJSInProcessObjectReference inProcessModule)
                                inProcessModule.Dispose();
                            else {
                                ValueTask valueTask = callbackModule.Result.DisposeAsync();
                                if (!valueTask.IsCompleted)
                                    taskList.Add(valueTask.AsTask());
                            }
                        callbackModule = null;


                """);
        builder.Append("""
                    if (taskList.Count == 0)
                        return ValueTask.CompletedTask;
                    else
                        return new ValueTask(Task.WhenAll(taskList));
                }
            }

            """);

        string source = builder.ToString();
        context.AddSource("TSRuntime.g.cs", source);
        stringBuilderPool.Return(builder);
    }
}
