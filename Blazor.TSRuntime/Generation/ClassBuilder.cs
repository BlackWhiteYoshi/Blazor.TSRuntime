using Microsoft.CodeAnalysis;
using Microsoft.Extensions.ObjectPool;
using System.Collections.Immutable;
using System.Text;
using TSRuntime.Configs;
using TSRuntime.Parsing;

namespace TSRuntime.Generation;

/// <summary>
/// Builds class TSRuntime.
/// </summary>
public static class ClassBuilder {
    /// <summary>
    /// Builds class TSRuntime.
    /// </summary>
    /// <param name="stringBuilderPool"></param>
    /// <param name="context"></param>
    /// <param name="parameters"></param>
    public static void BuildClass(this ObjectPool<StringBuilder> stringBuilderPool, SourceProductionContext context, (ImmutableArray<TSModule> moduleList, (Config? config, Diagnostic? error) configOrError) parameters) {
        if (parameters.configOrError.error is not null) {
            context.ReportDiagnostic(parameters.configOrError.error);
            return;
        }

        ImmutableArray<TSModule> moduleList = parameters.moduleList;
        Config config = parameters.configOrError.config!;


        foreach (Diagnostic error in config.ErrorList)
            context.ReportDiagnostic(error);


        StringBuilder builder = stringBuilderPool.Get();

        // usings, namespace, summary
        builder.Append("""
            // <auto-generated/>
            #pragma warning disable
            #nullable enable annotations


            using System;
            using System.Collections.Generic;
            using System.Threading;
            using System.Threading.Tasks;
            
            namespace Microsoft.JSInterop;

            /// <summary>
            /// <para>An implementation for <see cref="ITSRuntime"/>.</para>
            /// <para>It manages JS-modules: It loads the modules, caches it in an array and disposing releases all modules.</para>
            /// <para>
            /// 
            """);
        switch (moduleList.Length) {
            case 0:
                builder.Append("There are no modules available.");
                break;
            case 1:
                builder.Append("There is 1 module available: ");
                builder.Append(moduleList[0].Name);
                break;
            default:
                builder.Append("There are ");
                builder.Append(moduleList.Length);
                builder.Append(" modules available:");
                foreach (TSModule module in moduleList) {
                    builder.Append("<br />\n/// - ");
                    builder.Append(module.Name);
                }
                break;
        }
        builder.Append('\n');
        builder.Append("/// </para>\n");
        builder.Append("/// </summary>\n");
        builder.Append($"[System.CodeDom.Compiler.GeneratedCodeAttribute(\"{AssemblyInfo.NAME}\", \"{AssemblyInfo.VERSION}\")]\n");

        // head
        builder.Append("public sealed class TSRuntime(IJSRuntime jsRuntime) : ");
        if (!config.ModuleGrouping)
            builder.Append("ITSRuntime, ");
        else {
            foreach (TSModule module in moduleList) {
                config.ModuleGroupingNamePattern.AppendNaming(builder, module.Name);
                builder.Append(',');
                builder.Append(' ');
            }
        }
        builder.Append("IDisposable, IAsyncDisposable {\n");

        builder.Append("    private readonly CancellationTokenSource cancellationTokenSource = new();\n\n");

        // LoadModules()
        foreach (TSModule module in moduleList) {
            builder.Append("    Task<IJSObjectReference> ");
            if (!config.ModuleGrouping)
                builder.Append("ITSRuntime");
            else
                config.ModuleGroupingNamePattern.AppendNaming(builder, module.Name);
            builder.Append(".Get");
            builder.Append(module.Name);
            builder.Append("Module() => Get");
            builder.Append(module.Name);
            builder.Append("Module();\n");

            builder.Append("    private Task<IJSObjectReference>? ");
            builder.Append(module.Name);
            builder.Append("Module;\n");

            builder.Append("    private Task<IJSObjectReference> Get");
            builder.Append(module.Name);
            builder.Append("Module()\n");
            builder.Append("        => ");
            builder.Append(module.Name);
            builder.Append("Module switch {\n");
            builder.Append("            Task<IJSObjectReference> { IsCompletedSuccessfully: true }\n");
            builder.Append("            or Task<IJSObjectReference> { IsCompleted: false } => ");
            builder.Append(module.Name);
            builder.Append("Module,\n");
            builder.Append("            _ => ");
            builder.Append(module.Name);
            builder.Append("Module = jsRuntime.InvokeAsync<IJSObjectReference>(\"import\", cancellationTokenSource.Token, \"");
            builder.Append(module.URLPath);
            builder.Append("\").AsTask()\n");
            builder.Append("        };\n\n");
        }

        // PreloadAllModules()
        builder.Append("    public Task ");
        builder.Append(config.PreloadAllModulesName);
        builder.Append("() {\n");
        foreach (TSModule module in moduleList) {
            builder.Append("        Get");
            builder.Append(module.Name);
            builder.Append("Module();\n");
        }
        builder.Append("\n        return Task.WhenAll([");
        if (moduleList.Length > 0) {
            foreach (TSModule module in moduleList) {
                builder.Append(module.Name);
                builder.Append("Module!, ");
            }
            builder.Length -= 2;
        }
        builder.Append("]);\n");
        builder.Append("    }\n\n\n");

        // script invoke methods
        builder.Append("""
                TResult ITSRuntime.TSInvoke<TResult>(string identifier, object?[]? args) => ((IJSInProcessRuntime)jsRuntime).Invoke<TResult>(identifier, args);

                ValueTask<TValue> ITSRuntime.TSInvokeTrySync<TValue>(string identifier, object?[]? args, CancellationToken cancellationToken) {
                    if (jsRuntime is IJSInProcessRuntime jsInProcessRuntime)
                        return ValueTask.FromResult(jsInProcessRuntime.Invoke<TValue>(identifier, args));
                    else
                        return jsRuntime.InvokeAsync<TValue>(identifier, cancellationToken, args);
                }

                ValueTask<TValue> ITSRuntime.TSInvokeAsync<TValue>(string identifier, object?[]? args, CancellationToken cancellationToken)
                    => jsRuntime.InvokeAsync<TValue>(identifier, cancellationToken, args);



            """);

        // BuildClassJsRuntime
        int builderLength = builder.Length;
        if (config.JSRuntimeSyncEnabled)
            builder.Append("""
                public TResult Invoke<TResult>(string identifier, params object?[]? args)
                    => ((IJSInProcessRuntime)jsRuntime).Invoke<TResult>(identifier, args);


            """);
        if (config.JSRuntimeTrySyncEnabled)
            builder.Append("""
                public ValueTask<TValue> InvokeTrySync<TValue>(string identifier, CancellationToken cancellationToken, params object?[]? args) {
                    if (jsRuntime is IJSInProcessRuntime jsInProcessRuntime)
                        return ValueTask.FromResult(jsInProcessRuntime.Invoke<TValue>(identifier, args));
                    else
                        return jsRuntime.InvokeAsync<TValue>(identifier, cancellationToken, args);
                }


            """);
        if (config.JSRuntimeAsyncEnabled)
            builder.Append("""
                public ValueTask<TValue> InvokeAsync<TValue>(string identifier, CancellationToken cancellationToken, params object?[]? args)
                    => jsRuntime.InvokeAsync<TValue>(identifier, cancellationToken, args);


            """);
        if (builderLength < builder.Length)
            builder.Append('\n');

        // Dispose
        builder.Append("""
                /// <summary>
                /// Releases each module synchronously if possible, otherwise asynchronously per fire and forget.
                /// </summary>
                public void Dispose() {
                    if (cancellationTokenSource.IsCancellationRequested)
                        return;

                    cancellationTokenSource.Cancel();
                    cancellationTokenSource.Dispose();
            """);
        foreach (TSModule module in moduleList) {
            builder.Append("\n\n");
            builder.Append("        if (");
            builder.Append(module.Name);
            builder.Append("Module?.IsCompletedSuccessfully == true)\n");
            builder.Append("            if (");
            builder.Append(module.Name);
            builder.Append("Module.Result is IJSInProcessObjectReference inProcessModule)\n");
            builder.Append("                inProcessModule.Dispose();\n");
            builder.Append("            else\n");
            builder.Append("                _ = ");
            builder.Append(module.Name);
            builder.Append("Module.Result.DisposeAsync().Preserve();\n");
            builder.Append("        ");
            builder.Append(module.Name);
            builder.Append("Module = null;");
        }
        builder.Append("\n    }\n\n");

        // DisposeAsync
        builder.Append("""
                /// <summary>
                /// <para>Releases each module synchronously if possible, otherwise asynchronously and returns a task that completes, when all module disposing tasks complete.</para>
                /// <para>The asynchronous disposing tasks are happening in parallel.</para>
                /// </summary>
                /// <returns></returns>
                public ValueTask DisposeAsync() {
                    if (cancellationTokenSource.IsCancellationRequested)
                        return ValueTask.CompletedTask;

                    cancellationTokenSource.Cancel();
                    cancellationTokenSource.Dispose();

                    List<Task> taskList = new(
            """);
        builder.Append(moduleList.Length);
        builder.Append(");\n\n");
        foreach (TSModule module in moduleList) {
            builder.Append("        if (");
            builder.Append(module.Name);
            builder.Append("Module?.IsCompletedSuccessfully == true)\n");
            builder.Append("            if (");
            builder.Append(module.Name);
            builder.Append("Module.Result is IJSInProcessObjectReference inProcessModule)\n");
            builder.Append("                inProcessModule.Dispose();\n");
            builder.Append("            else {\n");
            builder.Append("                ValueTask valueTask = ");
            builder.Append(module.Name);
            builder.Append("Module.Result.DisposeAsync();\n");
            builder.Append("                if (!valueTask.IsCompleted)\n");
            builder.Append("                    taskList.Add(valueTask.AsTask());\n");
            builder.Append("            }\n");
            builder.Append("        ");
            builder.Append(module.Name);
            builder.Append("Module = null;\n\n");
        }
        builder.Append("""
                    if (taskList.Count == 0)
                        return ValueTask.CompletedTask;
                    else
                        return new ValueTask(Task.WhenAll(taskList));
                }
            }

            """);

        string source = builder.ToString();
        context.AddSource("TSRuntime.g.cs", source);
        stringBuilderPool.Return(builder);
    }
}
