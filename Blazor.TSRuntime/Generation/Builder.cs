using Microsoft.CodeAnalysis;
using Microsoft.Extensions.ObjectPool;
using System.Collections.Immutable;
using System.Text;
using TSRuntime.Configs;
using TSRuntime.Parsing;

namespace TSRuntime.Generation;

/// <summary>
/// Contains the 2 functions for generating the content for the class "TSRuntime" and the interface "ITSRuntime".
/// </summary>
public static class Builder {
    private const string ASSEMBLY_NAME = "Blazor.TSRuntime";
    private const string ASSEMBLY_VERSION = "0.6.0";


    /// <summary>
    /// Builds class TSRuntime.
    /// </summary>
    /// <param name="stringBuilderPool"></param>
    /// <param name="context"></param>
    /// <param name="parameters"></param>
    public static void BuildClass(this ObjectPool<StringBuilder> stringBuilderPool, SourceProductionContext context, (ImmutableArray<TSModule> moduleList, (Config? config, Diagnostic? error) configOrError) parameters) {
        if (parameters.configOrError.error is not null) {
            context.ReportDiagnostic(parameters.configOrError.error);
            return;
        }

        ImmutableArray<TSModule> moduleList = parameters.moduleList;
        Config config = parameters.configOrError.config!;

        
        foreach (Diagnostic error in config.ErrorList)
            context.ReportDiagnostic(error);


        StringBuilder builder = stringBuilderPool.Get();

        // usings, namespace, summary
        builder.Append("""
            // <auto-generated/>
            #pragma warning disable
            #nullable enable annotations


            using System;
            using System.Collections.Generic;
            using System.Threading;
            using System.Threading.Tasks;
            
            namespace Microsoft.JSInterop;

            /// <summary>
            /// <para>An implementation for <see cref="ITSRuntime"/>.</para>
            /// <para>It manages JS-modules: It loads the modules, caches it in an array and disposing releases all modules.</para>
            /// <para>
            /// 
            """);
        switch (moduleList.Length) {
            case 0:
                builder.Append("There are no modules available.");
                break;
            case 1:
                builder.Append("There is 1 module available: ");
                builder.Append(moduleList[0].Name);
                break;
            default:
                builder.Append("There are ");
                builder.Append(moduleList.Length);
                builder.Append(" modules available:");
                foreach (TSModule module in moduleList) {
                    builder.Append("<br />\n/// - ");
                    builder.Append(module.Name);
                }
                break;
        }
        builder.Append('\n');
        builder.Append("/// </para>\n");
        builder.Append("/// </summary>\n");
        builder.Append($"[System.CodeDom.Compiler.GeneratedCodeAttribute(\"{ASSEMBLY_NAME}\", \"{ASSEMBLY_VERSION}\")]\n");

        // head
        builder.Append("public sealed class TSRuntime(IJSRuntime jsRuntime) : ");
        if (!config.ModuleGrouping)
            builder.Append("ITSRuntime, ");
        else {
            foreach (TSModule module in moduleList) {
                config.ModuleGroupingNamePattern.AppendNaming(builder, module.Name);
                builder.Append(',');
                builder.Append(' ');
            }
        }
        builder.Append("IDisposable, IAsyncDisposable {\n");

        builder.Append("    private readonly CancellationTokenSource cancellationTokenSource = new();\n\n");

        // LoadModules()
        foreach (TSModule module in moduleList) {
            builder.Append("    Task<IJSObjectReference> ");
            if (!config.ModuleGrouping)
                builder.Append("ITSRuntime");
            else
                config.ModuleGroupingNamePattern.AppendNaming(builder, module.Name);
            builder.Append(".Get");
            builder.Append(module.Name);
            builder.Append("Module() => Get");
            builder.Append(module.Name);
            builder.Append("Module();\n");

            builder.Append("    private Task<IJSObjectReference>? ");
            builder.Append(module.Name);
            builder.Append("Module;\n");

            builder.Append("    private Task<IJSObjectReference> Get");
            builder.Append(module.Name);
            builder.Append("Module()\n");
            builder.Append("        => ");
            builder.Append(module.Name);
            builder.Append("Module switch {\n");
            builder.Append("            Task<IJSObjectReference> { IsCompletedSuccessfully: true }\n");
            builder.Append("            or Task<IJSObjectReference> { IsCompleted: false } => ");
            builder.Append(module.Name);
            builder.Append("Module,\n");
            builder.Append("            _ => ");
            builder.Append(module.Name);
            builder.Append("Module = jsRuntime.InvokeAsync<IJSObjectReference>(\"import\", cancellationTokenSource.Token, \"");
            builder.Append(module.URLPath);
            builder.Append("\").AsTask()\n");
            builder.Append("        };\n\n");
        }

        // PreloadAllModules()
        builder.Append("    public Task ");
        builder.Append(config.PreloadAllModulesName);
        builder.Append("() {\n");
        foreach (TSModule module in moduleList) {
            builder.Append("        Get");
            builder.Append(module.Name);
            builder.Append("Module();\n");
        }
        builder.Append("\n        return Task.WhenAll([");
        if (moduleList.Length > 0) {
            foreach (TSModule module in moduleList) {
                builder.Append(module.Name);
                builder.Append("Module!, ");
            }
            builder.Length -= 2;
        }
        builder.Append("]);\n");
        builder.Append("    }\n\n\n");

        // BuildClassJsRuntime
        int builderLength = builder.Length;
        if (config.JSRuntimeSyncEnabled)
            builder.Append("""
                public TResult Invoke<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicConstructors | DynamicallyAccessedMemberTypes.PublicFields | DynamicallyAccessedMemberTypes.PublicProperties)] TResult>(string identifier, params object?[]? args)
                    => ((IJSInProcessRuntime)jsRuntime).Invoke<TResult>(identifier, args);


            """);
        if (config.JSRuntimeTrySyncEnabled)
            builder.Append("""
                public ValueTask<TValue> InvokeTrySync<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicConstructors | DynamicallyAccessedMemberTypes.PublicFields | DynamicallyAccessedMemberTypes.PublicProperties)] TValue>(string identifier, CancellationToken cancellationToken, params object?[]? args) {
                    if (jsRuntime is IJSInProcessRuntime jsInProcessRuntime)
                        return ValueTask.FromResult(jsInProcessRuntime.Invoke<TValue>(identifier, args));
                    else
                        return jsRuntime.InvokeAsync<TValue>(identifier, cancellationToken, args);
                }


            """);
        if (config.JSRuntimeAsyncEnabled)
            builder.Append("""
                public ValueTask<TValue> InvokeAsync<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicConstructors | DynamicallyAccessedMemberTypes.PublicFields | DynamicallyAccessedMemberTypes.PublicProperties)] TValue>(string identifier, CancellationToken cancellationToken, params object?[]? args)
                    => jsRuntime.InvokeAsync<TValue>(identifier, cancellationToken, args);


            """);
        if (builderLength < builder.Length)
            builder.Append('\n');

        // Dispose
        builder.Append("""
                /// <summary>
                /// Releases each module synchronously if possible, otherwise asynchronously per fire and forget.
                /// </summary>
                public void Dispose() {
                    if (cancellationTokenSource.IsCancellationRequested)
                        return;

                    cancellationTokenSource.Cancel();
                    cancellationTokenSource.Dispose();
            """);
        foreach (TSModule module in moduleList) {
            builder.Append("\n\n");
            builder.Append("        if (");
            builder.Append(module.Name);
            builder.Append("Module?.IsCompletedSuccessfully == true)\n");
            builder.Append("            if (");
            builder.Append(module.Name);
            builder.Append("Module.Result is IJSInProcessObjectReference inProcessModule)\n");
            builder.Append("                inProcessModule.Dispose();\n");
            builder.Append("            else\n");
            builder.Append("                _ = ");
            builder.Append(module.Name);
            builder.Append("Module.Result.DisposeAsync().Preserve();\n");
            builder.Append("        ");
            builder.Append(module.Name);
            builder.Append("Module = null;");
        }
        builder.Append("\n    }\n\n");

        // DisposeAsync
        builder.Append("""
                /// <summary>
                /// <para>Releases each module synchronously if possible, otherwise asynchronously and returns a task that completes, when all module disposing tasks complete.</para>
                /// <para>The asynchronous disposing tasks are happening in parallel.</para>
                /// </summary>
                /// <returns></returns>
                public ValueTask DisposeAsync() {
                    if (cancellationTokenSource.IsCancellationRequested)
                        return ValueTask.CompletedTask;

                    cancellationTokenSource.Cancel();
                    cancellationTokenSource.Dispose();

                    List<Task> taskList = new(
            """);
        builder.Append(moduleList.Length);
        builder.Append(");\n\n");
        foreach (TSModule module in moduleList) {
            builder.Append("        if (");
            builder.Append(module.Name);
            builder.Append("Module?.IsCompletedSuccessfully == true)\n");
            builder.Append("            if (");
            builder.Append(module.Name);
            builder.Append("Module.Result is IJSInProcessObjectReference inProcessModule)\n");
            builder.Append("                inProcessModule.Dispose();\n");
            builder.Append("            else {\n");
            builder.Append("                ValueTask valueTask = ");
            builder.Append(module.Name);
            builder.Append("Module.Result.DisposeAsync();\n");
            builder.Append("                if (!valueTask.IsCompleted)\n");
            builder.Append("                    taskList.Add(valueTask.AsTask());\n");
            builder.Append("            }\n");
            builder.Append("        ");
            builder.Append(module.Name);
            builder.Append("Module = null;\n\n");
        }
        builder.Append("""
                    if (taskList.Count == 0)
                        return ValueTask.CompletedTask;
                    else
                        return new ValueTask(Task.WhenAll(taskList));
                }
            }

            """);

        string source = builder.ToString();
        context.AddSource("TSRuntime.g.cs", source);
        stringBuilderPool.Return(builder);
    }


    #region BuildInterface

    /// <summary>
    /// The basic content of the interface is added:<br />
    /// - GetOrLoadModule()<br />
    /// - PreloadAllModules()<br />
    /// - JSRUNTIME methods (Sync/TrySync/Async)<br />
    /// - private Invoke-methods (Sync/TrySync/Async)
    /// </summary>
    public static void BuildInterfaceCore(SourceProductionContext context, (Config? config, Diagnostic? error) configOrError) {
        if (configOrError.error is not null)
            return;

        Config config = configOrError.config!;

        string privateOrProtected;
        string partialOrEmpty;
        string interfaceSummary;
        if (!config.ModuleGrouping) {
            privateOrProtected = "private";
            partialOrEmpty = "partial ";
            interfaceSummary = """
                /// <summary>
                /// <para>Interface for JS-interop.</para>
                /// <para>It contains an invoke-method for every js-function, a preload-method for every module and a method to load all modules.</para>
                /// </summary>
                """;
        }
        else {
            privateOrProtected = "protected";
            partialOrEmpty = string.Empty;
            interfaceSummary = """
                /// <summary>
                /// <para>Interface to preload all modules.</para>
                /// <para>To invoke JS-interop methods or load a specific module, use the dedicated interface for the corresponding module.</para>
                /// </summary>
                """;
        }

        const string JSRUNTIME_SYNC = """
                /// <summary>
                /// Invokes the specified JavaScript function synchronously.
                /// </summary>
                /// <param name="identifier">An identifier for the function to invoke. For example, the value <c>"someScope.someFunction"</c> will invoke the function <c>window.someScope.someFunction</c>.</param>
                /// <param name="args">JSON-serializable arguments.</param>
                public void InvokeVoid(string identifier, params object?[]? args)
                    => Invoke<Infrastructure.IJSVoidResult>(identifier, args);
        
                /// <summary>
                /// Invokes the specified JavaScript function synchronously.
                /// </summary>
                /// <typeparam name="TResult">The JSON-serializable return type.</typeparam>
                /// <param name="identifier">An identifier for the function to invoke. For example, the value <c>"someScope.someFunction"</c> will invoke the function <c>window.someScope.someFunction</c>.</param>
                /// <param name="args">JSON-serializable arguments.</param>
                /// <returns>An instance of <typeparamref name="TResult"/> obtained by JSON-deserializing the return value.</returns>
                public TResult Invoke<TResult>(string identifier, params object?[]? args);
            """;

        const string JSRUNTIME_TRYSYNC = """
                /// <summary>
                /// This method performs synchronous, if the underlying implementation supports synchrounous interoperability.
                /// </summary>
                /// <param name="identifier">An identifier for the function to invoke. For example, the value <c>"someScope.someFunction"</c> will invoke the function <c>window.someScope.someFunction</c>.</param>
                /// <param name="args">JSON-serializable arguments.</param>
                /// <returns></returns>
                public async ValueTask InvokeVoidTrySync(string identifier, params object?[]? args)
                    => await InvokeTrySync<Infrastructure.IJSVoidResult>(identifier, default, args);
        
                /// <summary>
                /// This method performs synchronous, if the underlying implementation supports synchrounous interoperability.
                /// </summary>
                /// <param name="identifier">An identifier for the function to invoke. For example, the value <c>"someScope.someFunction"</c> will invoke the function <c>window.someScope.someFunction</c>.</param>
                /// <param name="cancellationToken">A cancellation token to signal the cancellation of the operation. Specifying this parameter will override any default cancellations such as due to timeouts (<see cref="JSRuntime.DefaultAsyncTimeout"/>) from being applied.</param>
                /// <param name="args">JSON-serializable arguments.</param>
                /// <returns></returns>
                public async ValueTask InvokeVoidTrySync(string identifier, CancellationToken cancellationToken, params object?[]? args)
                    => await InvokeTrySync<Infrastructure.IJSVoidResult>(identifier, cancellationToken, args);
        
                /// <summary>
                /// This method performs synchronous, if the underlying implementation supports synchrounous interoperability.
                /// </summary>
                /// <typeparam name="TValue">The JSON-serializable return type.</typeparam>
                /// <param name="identifier">An identifier for the function to invoke. For example, the value <c>"someScope.someFunction"</c> will invoke the function <c>window.someScope.someFunction</c>.</param>
                /// <param name="args">JSON-serializable arguments.</param>
                /// <returns>An instance of <typeparamref name="TValue"/> obtained by JSON-deserializing the return value.</returns>
                public ValueTask<TValue> InvokeTrySync<TValue>(string identifier, params object?[]? args)
                    => InvokeTrySync<TValue>(identifier, default, args);
        
                /// <summary>
                /// This method performs synchronous, if the underlying implementation supports synchrounous interoperability.
                /// </summary>
                /// <typeparam name="TValue">The JSON-serializable return type.</typeparam>
                /// <param name="identifier">An identifier for the function to invoke. For example, the value <c>"someScope.someFunction"</c> will invoke the function <c>window.someScope.someFunction</c>.</param>
                /// <param name="cancellationToken">A cancellation token to signal the cancellation of the operation. Specifying this parameter will override any default cancellations such as due to timeouts (<see cref="JSRuntime.DefaultAsyncTimeout"/>) from being applied.</param>
                /// <param name="args">JSON-serializable arguments.</param>
                /// <returns>An instance of <typeparamref name="TValue"/> obtained by JSON-deserializing the return value.</returns>
                public ValueTask<TValue> InvokeTrySync<TValue>(string identifier, CancellationToken cancellationToken, params object?[]? args);
            """;

        const string JSRUNTIME_ASYNC = """
                /// <summary>
                /// Invokes the specified JavaScript function asynchronously.
                /// <para>
                /// <see cref="JSRuntime"/> will apply timeouts to this operation based on the value configured in <see cref="JSRuntime.DefaultAsyncTimeout"/>. To dispatch a call with a different timeout, or no timeout,
                /// consider using <see cref="InvokeVoidAsync{TValue}(string, CancellationToken, object[])" />.
                /// </para>
                /// </summary>
                /// <param name="identifier">An identifier for the function to invoke. For example, the value <c>"someScope.someFunction"</c> will invoke the function <c>window.someScope.someFunction</c>.</param>
                /// <param name="args">JSON-serializable arguments.</param>
                /// <returns></returns>
                public async ValueTask InvokeVoidAsync(string identifier, params object?[]? args)
                    => await InvokeAsync<Infrastructure.IJSVoidResult>(identifier, default, args);
        
                /// <summary>
                /// Invokes the specified JavaScript function asynchronously.
                /// </summary>
                /// <param name="identifier">An identifier for the function to invoke. For example, the value <c>"someScope.someFunction"</c> will invoke the function <c>window.someScope.someFunction</c>.</param>
                /// <param name="cancellationToken">
                /// A cancellation token to signal the cancellation of the operation. Specifying this parameter will override any default cancellations such as due to timeouts
                /// (<see cref="JSRuntime.DefaultAsyncTimeout"/>) from being applied.
                /// </param>
                /// <param name="args">JSON-serializable arguments.</param>
                /// <returns></returns>
                public async ValueTask InvokeVoidAsync(string identifier, CancellationToken cancellationToken, params object?[]? args)
                    => await InvokeAsync<Infrastructure.IJSVoidResult>(identifier, cancellationToken, args);
        
                /// <summary>
                /// Invokes the specified JavaScript function asynchronously.
                /// <para>
                /// <see cref="JSRuntime"/> will apply timeouts to this operation based on the value configured in <see cref="JSRuntime.DefaultAsyncTimeout"/>. To dispatch a call with a different timeout, or no timeout,
                /// consider using <see cref="InvokeAsync{TValue}(string, CancellationToken, object[])" />.
                /// </para>
                /// </summary>
                /// <typeparam name="TValue">The JSON-serializable return type.</typeparam>
                /// <param name="identifier">An identifier for the function to invoke. For example, the value <c>"someScope.someFunction"</c> will invoke the function <c>window.someScope.someFunction</c>.</param>
                /// <param name="args">JSON-serializable arguments.</param>
                /// <returns>An instance of <typeparamref name="TValue"/> obtained by JSON-deserializing the return value.</returns>
                public ValueTask<TValue> InvokeAsync<TValue>(string identifier, params object?[]? args)
                    => InvokeAsync<TValue>(identifier, default, args);
        
                /// <summary>
                /// Invokes the specified JavaScript function asynchronously.
                /// </summary>
                /// <typeparam name="TValue">The JSON-serializable return type.</typeparam>
                /// <param name="identifier">An identifier for the function to invoke. For example, the value <c>"someScope.someFunction"</c> will invoke the function <c>window.someScope.someFunction</c>.</param>
                /// <param name="cancellationToken">
                /// A cancellation token to signal the cancellation of the operation. Specifying this parameter will override any default cancellations such as due to timeouts
                /// (<see cref="JSRuntime.DefaultAsyncTimeout"/>) from being applied.
                /// </param>
                /// <param name="args">JSON-serializable arguments.</param>
                /// <returns>An instance of <typeparamref name="TValue"/> obtained by JSON-deserializing the return value.</returns>
                public ValueTask<TValue> InvokeAsync<TValue>(string identifier, CancellationToken cancellationToken, params object?[]? args);
            """;

        string jsRuntimeMethods = (config.JSRuntimeSyncEnabled, config.JSRuntimeTrySyncEnabled, config.JSRuntimeAsyncEnabled) switch {
            (true, true, true) => $"\n\n{JSRUNTIME_SYNC}\n\n{JSRUNTIME_TRYSYNC}\n\n{JSRUNTIME_ASYNC}\n",
            (true, true, false) => $"\n\n{JSRUNTIME_SYNC}\n\n{JSRUNTIME_TRYSYNC}\n",
            (true, false, true) => $"\n\n{JSRUNTIME_SYNC}\n\n{JSRUNTIME_ASYNC}\n",
            (false, true, true) => $"\n\n{JSRUNTIME_TRYSYNC}\n\n{JSRUNTIME_ASYNC}\n",
            (true, false, false) => $"\n\n{JSRUNTIME_SYNC}\n",
            (false, true, false) => $"\n\n{JSRUNTIME_TRYSYNC}\n",
            (false, false, true) => $"\n\n{JSRUNTIME_ASYNC}\n",
            (false, false, false) => ""
        };


        string source = $$"""
            // <auto-generated/>
            #pragma warning disable
            #nullable enable annotations


            using System.Threading;
            using System.Threading.Tasks;
            
            namespace Microsoft.JSInterop;

            {{interfaceSummary}}
            [System.CodeDom.Compiler.GeneratedCodeAttribute("{{ASSEMBLY_NAME}}", "{{ASSEMBLY_VERSION}}")]
            public {{partialOrEmpty}}interface ITSRuntime {
                /// <summary>
                /// <para>Fetches all modules as javascript-modules.</para>
                /// <para>If already loading, it doesn't trigger a second loading and if any already loaded, these are not loaded again, so if all already loaded, it returns a completed task.</para>
                /// </summary>
                /// <returns>A Task that will complete when all module loading Tasks have completed.</returns>
                public Task {{config.PreloadAllModulesName}}();
                {{jsRuntimeMethods}}

                /// <summary>
                /// <para>Invokes the specified JavaScript function in the specified module synchronously.</para>
                /// <para>If module is not loaded, it returns without any invoking. If synchronous is not supported, it fails with an exception.</para>
                /// </summary>
                /// <typeparam name="T"></typeparam>
                /// <param name="moduleUrl">complete path of the module, e.g. "/Pages/Example.razor.js"</param>
                /// <param name="identifier">name of the javascript function</param>
                /// <param name="success">false when the module is not loaded, otherwise true</param>
                /// <param name="args">parameter passing to the JS-function</param>
                /// <returns>default when the module is not loaded, otherwise result of the JS-function</returns>
                {{privateOrProtected}} TResult Invoke<TResult>(Task<IJSObjectReference> moduleTask, string identifier, params object?[]? args) {
                    if (!moduleTask.IsCompletedSuccessfully)
                        throw new JSException("JS-module is not loaded. Use and await the Preload-method to ensure the module is loaded.");

                    return ((IJSInProcessObjectReference)moduleTask.Result).Invoke<TResult>(identifier, args);
                }

                /// <summary>
                /// Invokes the specified JavaScript function in the specified module synchronously when supported, otherwise asynchronously.
                /// </summary>
                /// <typeparam name="T"></typeparam>
                /// <param name="moduleUrl">complete path of the module, e.g. "/Pages/Example.razor.js"</param>
                /// <param name="identifier">name of the javascript function</param>
                /// <param name="cancellationToken">A cancellation token to signal the cancellation of the operation. Specifying this parameter will override any default cancellations such as due to timeouts (<see cref="JSRuntime.DefaultAsyncTimeout"/>) from being applied.</param>
                /// <param name="args">parameter passing to the JS-function</param>
                /// <returns></returns>
                {{privateOrProtected}} async ValueTask<TValue> InvokeTrySync<TValue>(Task<IJSObjectReference> moduleTask, string identifier, CancellationToken cancellationToken, params object?[]? args) {
                    IJSObjectReference module = await moduleTask;
                    if (module is IJSInProcessObjectReference inProcessModule)
                        return inProcessModule.Invoke<TValue>(identifier, args);
                    else
                        return await module.InvokeAsync<TValue>(identifier, cancellationToken, args);
                }

                /// <summary>
                /// Invokes the specified JavaScript function in the specified module asynchronously.
                /// </summary>
                /// <typeparam name="T"></typeparam>
                /// <param name="moduleUrl">complete path of the module, e.g. "/Pages/Example.razor.js"</param>
                /// <param name="identifier">name of the javascript function</param>
                /// <param name="cancellationToken">A cancellation token to signal the cancellation of the operation. Specifying this parameter will override any default cancellations such as due to timeouts (<see cref="JSRuntime.DefaultAsyncTimeout"/>) from being applied.</param>
                /// <param name="args">parameter passing to the JS-function</param>
                /// <returns></returns>
                {{privateOrProtected}} async ValueTask<TValue> InvokeAsync<TValue>(Task<IJSObjectReference> moduleTask, string identifier, CancellationToken cancellationToken, params object?[]? args) {
                    IJSObjectReference module = await moduleTask;
                    return await module.InvokeAsync<TValue>(identifier, cancellationToken, args);
                }
            }

            """;

        context.AddSource("ITSRuntime_Core.g.cs", source);
    }

    /// <summary>
    /// Builds the content of a module:
    /// - Preload-method<br />
    /// - module methods
    /// </summary>
    /// <param name="stringBuilderPool"></param>
    /// <param name="context"></param>
    /// <param name="parameters"></param>
    public static void BuildInterfaceModule(this ObjectPool<StringBuilder> stringBuilderPool, SourceProductionContext context, (TSModule module, Config config) parameters) {
        StringBuilder builder = stringBuilderPool.Get();

        (string hintName, string source) = new BuildInterfaceModuleCore(builder, parameters.module, parameters.config).Build();

        context.AddSource(hintName, source);
        stringBuilderPool.Return(builder);
    }

    /// <summary>
    /// Datastructure used in <see cref="BuildInterfaceModule"/>.
    /// </summary>
    /// <param name="builder"></param>
    /// <param name="module"></param>
    /// <param name="config"></param>
    /// <param name="index"></param>
    private struct BuildInterfaceModuleCore(StringBuilder builder, TSModule module, Config config) {
        private TSFunction function;
        private readonly List<GenericType> genericParameterList = [];
        private readonly List<MappedType> mappedParameterList = [];
        private MappedType mappedReturnType;
        private string returnType;
        private string returnModifiers;


        /// <summary>
        /// Builds the interface module.
        /// </summary>
        /// <returns></returns>
        public (string hintName, string source) Build() {
            builder.Append("""
            // <auto-generated/>
            #pragma warning disable
            #nullable enable annotations


            using System.Threading;
            using System.Threading.Tasks;

            """);
            foreach (string usingStatement in config.UsingStatements) {
                builder.Append("using ");
                builder.Append(usingStatement);
                builder.Append(";\n");
            }
            builder.Append('\n');

            builder.Append("namespace Microsoft.JSInterop;\n\n");

            // head
            if (!config.ModuleGrouping)
                builder.Append("public partial interface ITSRuntime {\n");
            else {
                // summary
                builder.Append("/// <summary>\n");
                builder.Append("/// <para>Interface to JS-interop the module '");
                builder.Append(module.Name);
                builder.Append("'.</para>\n");
                builder.Append("/// <para>It contains invoke-methods for the js-functions and a preload-method for loading the module of '");
                builder.Append(module.Name);
                builder.Append("'.</para>\n");
                builder.Append("/// </summary>\n");

                builder.Append($"[System.CodeDom.Compiler.GeneratedCodeAttribute(\"{ASSEMBLY_NAME}\", \"{ASSEMBLY_VERSION}\")]\n");

                builder.Append("public interface ");
                config.ModuleGroupingNamePattern.AppendNaming(builder, module.Name);
                builder.Append(" : ITSRuntime {\n");
            }

            // preload module
            {
                builder.Append("    protected Task<IJSObjectReference> Get");
                builder.Append(module.Name);
                builder.Append("Module();\n\n");

                builder.Append("    /// <summary>\n");
                builder.Append("    /// <para>Loads '");
                builder.Append(module.Name);
                builder.Append("' (");
                builder.Append(module.URLPath);
                builder.Append(") as javascript-module.</para>\n");
                builder.Append("    /// <para>If already loading, it does not trigger a second loading and if already loaded, it returns a completed task.</para>\n");
                builder.Append("    /// </summary>\n");
                builder.Append("    /// <returns>A Task that will complete when the module import have completed.</returns>\n");

                builder.Append("    public Task ");
                config.PreloadNamePattern.AppendNaming(builder, module.Name);
                builder.Append("() => Get");
                builder.Append(module.Name);
                builder.Append("Module();\n\n\n");
            }

            if (module.FunctionList.Count > 0) {
                mappedParameterList.Clear();
                genericParameterList.Clear();
                for (int i = 0; i < module.FunctionList.Count; i++) {
                    function = module.FunctionList[i];

                    mappedParameterList.Clear();
                    for (int j = 0; j < function.ParameterList.Length; j++)
                        if (config.TypeMap.TryGetValue(function.ParameterList[j].type, out MappedType mappedType))
                            mappedParameterList.Add(mappedType);
                        else
                            mappedParameterList.Add(new MappedType(function.ParameterList[j].type));

                    if (!config.TypeMap.TryGetValue(function.ReturnType.type, out mappedReturnType))
                        mappedReturnType = new(function.ReturnType.type);

                    returnType = mappedReturnType.Type;
                    returnModifiers = (function.ReturnType.typeNullable, function.ReturnType.array, function.ReturnType.arrayNullable) switch {
                        (false, false, _) => string.Empty,
                        (true, false, _) => "?",
                        (false, true, false) => "[]",
                        (false, true, true) => "[]?",
                        (true, true, false) => "?[]",
                        (true, true, true) => "?[]?"
                    };

                    if (function.ReturnPromise && config.PromiseOnlyAsync)
                        AppendInvokeAsyncMethod("asynchronously.", config.InvokeFunctionActionNameAsync, "InvokeAsync");
                    else {
                        if (config.InvokeFunctionSyncEnabled)
                            AppendInvokeSyncMethod("synchronously.", config.InvokeFunctionActionNameSync, "Invoke");
                        if (config.InvokeFunctionTrySyncEnabled)
                            AppendInvokeAsyncMethod("synchronously when supported, otherwise asynchronously.", config.InvokeFunctionActionNameTrySync, "InvokeTrySync");
                        if (config.InvokeFunctionAsyncEnabled)
                            AppendInvokeAsyncMethod("asynchronously.", config.InvokeFunctionActionNameAsync, "InvokeAsync");
                    }
                }
                builder.Append('\n');
            }

            builder.Length -= 2;
            builder.Append("}\n");


            string source = builder.ToString();

            builder.Clear();
            if (!config.ModuleGrouping) {
                builder.Append("ITSRuntime_");
                builder.Append(module.Name);
            }
            else
                config.ModuleGroupingNamePattern.AppendNaming(builder, module.Name);
            builder.Append(".g.cs");
            string hintName = builder.ToString();

            return (hintName, source);
        }


        /// <summary>
        /// <para>Appends the invoke method for a js function.</para>
        /// <para>
        /// If the parameterlist of the js function ends on optional variables, corresponding overload methods are created.<br />
        /// In this case multiple methods for that js function are appended.
        /// </para>
        /// <para>This method builds for sync Invoke calls only.</para>
        /// </summary>
        /// <param name="summaryAction"></param>
        /// <param name="invokeFunctionActionName"></param>
        /// <param name="invokeFunction"></param>
        private readonly void AppendInvokeSyncMethod(string summaryAction, string invokeFunctionActionName, string invokeFunction)
            => AppendInvokeMethodCore(summaryAction, invokeFunctionActionName, invokeFunction, isSync: true);

        /// <summary>
        /// <para>Appends the invoke method for a js function.</para>
        /// <para>
        /// If the parameterlist of the js function ends on optional variables, corresponding overload methods are created.<br />
        /// In this case multiple methods for that js function are appended.
        /// </para>
        /// <para>This method builds for async Invoke calls (TrySync, Async).</para>
        /// </summary>
        /// <param name="summaryAction"></param>
        /// <param name="invokeFunctionActionName"></param>
        /// <param name="invokeFunction"></param>
        private readonly void AppendInvokeAsyncMethod(string summaryAction, string invokeFunctionActionName, string invokeFunction)
            => AppendInvokeMethodCore(summaryAction, invokeFunctionActionName, invokeFunction, isSync: false);

        /// <summary>
        /// Core method for <see cref="AppendInvokeSyncMethod"/> and <see cref="AppendInvokeAsyncMethod"/>.
        /// </summary>
        /// <param name="summaryAction"></param>
        /// <param name="invokeFunctionActionName"></param>
        /// <param name="invokeFunction"></param>
        /// <param name="isSync"></param>
        private readonly void AppendInvokeMethodCore(string summaryAction, string invokeFunctionActionName, string invokeFunction, bool isSync) {
            int lastIndex = function.ParameterList.Length;
            do {
                lastIndex--;

                genericParameterList.Clear();
                for (int i = 0; i <= lastIndex; i++)
                    for (int j = 0; j < mappedParameterList[i].GenericTypes.Length; j++)
                        if (!genericParameterList.Contains(mappedParameterList[i].GenericTypes[j]))
                            genericParameterList.Add(mappedParameterList[i].GenericTypes[j]);
                for (int i = 0; i < mappedReturnType.GenericTypes.Length; i++)
                    if (!genericParameterList.Contains(mappedReturnType.GenericTypes[i]))
                        genericParameterList.Add(mappedReturnType.GenericTypes[i]);

                builder.Append("    /// <summary>\n");
                builder.Append("    /// <para>Invokes in module '");
                builder.Append(module.Name);
                builder.Append("' the JS-function '");
                builder.Append(function.Name);
                builder.Append("' ");
                builder.Append(summaryAction);
                builder.Append("</para>\n");
                if (isSync)
                    builder.Append("    /// <para>If module is not loaded or synchronous is not supported, it fails with an exception.</para>\n");
                builder.Append("    /// </summary>\n");
                foreach (GenericType genericType in genericParameterList) {
                    builder.Append("    /// <typeparam name=\"");
                    builder.Append(genericType.Name);
                    builder.Append("\"></typeparam>\n");
                }
                for (int i = 0; i <= lastIndex; i++) {
                    builder.Append("    /// <param name=\"");
                    builder.Append(function.ParameterList[i].name);
                    builder.Append("\"></param>\n");
                }
                if (isSync) {
                    if (returnType != "void")
                        builder.Append("    /// <returns>Result of the JS-function.</returns>\n");

                    builder.Append("    public ");
                    builder.Append(returnType);
                    builder.Append(returnModifiers);
                    builder.Append(' ');
                }
                else {
                    builder.Append("    /// <param name=\"cancellationToken\">A cancellation token to signal the cancellation of the operation. Specifying this parameter will override any default cancellations such as due to timeouts (<see cref=\"JSRuntime.DefaultAsyncTimeout\"/>) from being applied.</param>\n");
                    if (returnType != "void")
                        builder.Append("    /// <returns>Result of the JS-function.</returns>\n");
                    else
                        builder.Append("    /// <returns>A Task that will complete when the JS-Function have completed.</returns>\n");

                    builder.Append("    public ");
                    if (returnType == "void")
                        builder.Append("Task ");
                    else {
                        builder.Append("ValueTask<");
                        builder.Append(returnType);
                        builder.Append(returnModifiers);
                        builder.Append("> ");
                    }
                }

                // method name
                config.InvokeFunctionNamePattern.AppendNaming(builder, module.Name, function.Name, invokeFunctionActionName);
                if (function.ReturnPromise && config.PromiseAppendAsync)
                    builder.Append("Async");

                // generic parameters
                if (genericParameterList.Count > 0 || function.Generics.Length > 0) {
                    builder.Append('<');
                    for (int i = 0; i < genericParameterList.Count; i++) {
                        builder.Append(genericParameterList[i].Name);
                        builder.Append(", ");
                    }
                    foreach (string genericType in function.Generics) {
                        builder.Append(genericType);
                        builder.Append(", ");
                    }
                    builder.Length -= 2;
                    builder.Append('>');
                }

                // parameters
                builder.Append('(');
                if (lastIndex >= 0) {
                    for (int i = 0; i <= lastIndex; i++) {
                        builder.Append(mappedParameterList[i].Type);
                        if (function.ParameterList[i].typeNullable)
                            builder.Append('?');
                        if (function.ParameterList[i].array)
                            builder.Append("[]");
                        if (function.ParameterList[i].arrayNullable)
                            builder.Append('?');
                        builder.Append(' ');
                        builder.Append(function.ParameterList[i].name);
                        builder.Append(", ");
                    }
                    if (isSync)
                        builder.Length -= 2;
                }
                if (!isSync)
                    builder.Append("CancellationToken cancellationToken = default");
                builder.Append(')');

                // generic constraints
                foreach (GenericType genericType in genericParameterList)
                    if (genericType.Constraint != null) {
                        builder.Append(" where ");
                        builder.Append(genericType.Name);
                        builder.Append(" : ");
                        builder.Append(genericType.Constraint);
                    }

                builder.Append("\n        => ");
                builder.Append(invokeFunction);
                builder.Append('<');
                if (returnType == "void")
                    builder.Append("Infrastructure.IJSVoidResult");
                else {
                    builder.Append(returnType);
                    builder.Append(returnModifiers);
                }
                builder.Append(">(Get");
                builder.Append(module.Name);
                builder.Append("Module(), \"");
                builder.Append(function.Name);
                builder.Append('"');
                if (!isSync)
                    builder.Append(", cancellationToken");
                if (lastIndex >= 0) {
                    builder.Append(", [");
                    for (int i = 0; i < lastIndex; i++) {
                        builder.Append(function.ParameterList[i].name);
                        builder.Append(", ");
                    }
                    builder.Append(function.ParameterList[lastIndex].name);
                    builder.Append(']');
                }
                builder.Append(')');

                if (!isSync)
                    if (returnType == "void") {
                        builder.Append(" switch {\n");
                        builder.Append("            ValueTask<");
                        if (returnType == "void")
                            builder.Append("Infrastructure.IJSVoidResult");
                        else {
                            builder.Append(returnType);
                            builder.Append(returnModifiers);
                        }
                        builder.Append("> { IsCompleted: true } => Task.CompletedTask,\n");
                        builder.Append("            ValueTask<");
                        if (returnType == "void")
                            builder.Append("Infrastructure.IJSVoidResult");
                        else {
                            builder.Append(returnType);
                            builder.Append(returnModifiers);
                        }
                        builder.Append("> task => task.AsTask()\n");
                        builder.Append("        }");
                    }

                builder.Append(";\n\n");
            } while (lastIndex >= 0 && function.ParameterList[lastIndex].optional);
        }
    }

    #endregion


    public static void BuildServiceExtension(this ObjectPool<StringBuilder> stringBuilderPool, SourceProductionContext context, (ImmutableArray<TSModule> moduleList, (Config? config, Diagnostic? error) configOrError) parameters) {
        if (parameters.configOrError.error is not null)
            return;

        Config config = parameters.configOrError.config!;
        ImmutableArray<TSModule> moduleList = parameters.moduleList;

        if (!config.ServiceExtension)
            return;


        StringBuilder builder = stringBuilderPool.Get();

        builder.Append("""
            // <auto-generated/>
            #pragma warning disable
            #nullable enable annotations


            using Microsoft.Extensions.DependencyInjection;
            
            namespace Microsoft.JSInterop;

            public static class TSRuntimeServiceExtension {
                /// <summary>
                /// Registers a scoped ITSRuntime with a TSRuntime as implementation and if available, registers the module interfaces with the same TSRuntime-object.
                /// </summary>
                /// <param name="services"></param>
                /// <returns></returns>
                public static IServiceCollection AddTSRuntime(this IServiceCollection services) {
                    services.AddScoped<ITSRuntime, TSRuntime>();


            """);

        if (config.ModuleGrouping)
            foreach (TSModule module in moduleList) {
                builder.Append("        services.AddScoped(serviceProvider => (");
                config.ModuleGroupingNamePattern.AppendNaming(builder, module.Name);
                builder.Append(")serviceProvider.GetRequiredService<ITSRuntime>());\n");
            }
        else
            builder.Length--;

        builder.Append("""

                    return services;
                }
            }
            
            """);


        string source = builder.ToString();
        context.AddSource("TSRuntime_ServiceExtension.g.cs", source);
        stringBuilderPool.Return(builder);
    }
}
