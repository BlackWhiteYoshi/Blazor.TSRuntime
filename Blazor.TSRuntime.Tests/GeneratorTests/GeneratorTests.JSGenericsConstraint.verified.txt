---------
TSRuntime
---------

// <auto-generated/>
#pragma warning disable
#nullable enable annotations


using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;

namespace Microsoft.JSInterop;

/// <summary>
/// <para>An implementation for <see cref="ITSRuntime"/>.</para>
/// <para>It manages JS-modules: It loads the modules, caches it in an array and disposing releases all modules.</para>
/// <para>
/// There is 1 module available: GenericModule
/// </para>
/// </summary>
[System.CodeDom.Compiler.GeneratedCodeAttribute("Blazor.TSRuntime", "0.6.0")]
public sealed class TSRuntime(IJSRuntime jsRuntime) : ITSRuntime, IDisposable, IAsyncDisposable {
    private readonly CancellationTokenSource cancellationTokenSource = new();

    Task<IJSObjectReference> ITSRuntime.GetGenericModuleModule() => GetGenericModuleModule();
    private Task<IJSObjectReference>? GenericModuleModule;
    private Task<IJSObjectReference> GetGenericModuleModule()
        => GenericModuleModule switch {
            Task<IJSObjectReference> { IsCompletedSuccessfully: true }
            or Task<IJSObjectReference> { IsCompleted: false } => GenericModuleModule,
            _ => GenericModuleModule = jsRuntime.InvokeAsync<IJSObjectReference>("import", cancellationTokenSource.Token, "/GenericModule.js").AsTask()
        };

    public Task PreloadAllModules() {
        GetGenericModuleModule();

        return Task.WhenAll([GenericModuleModule!]);
    }


    /// <summary>
    /// Releases each module synchronously if possible, otherwise asynchronously per fire and forget.
    /// </summary>
    public void Dispose() {
        if (cancellationTokenSource.IsCancellationRequested)
            return;

        cancellationTokenSource.Cancel();
        cancellationTokenSource.Dispose();

        if (GenericModuleModule?.IsCompletedSuccessfully == true)
            if (GenericModuleModule.Result is IJSInProcessObjectReference inProcessModule)
                inProcessModule.Dispose();
            else
                _ = GenericModuleModule.Result.DisposeAsync().Preserve();
        GenericModuleModule = null;
    }

    /// <summary>
    /// <para>Releases each module synchronously if possible, otherwise asynchronously and returns a task that completes, when all module disposing tasks complete.</para>
    /// <para>The asynchronous disposing tasks are happening in parallel.</para>
    /// </summary>
    /// <returns></returns>
    public ValueTask DisposeAsync() {
        if (cancellationTokenSource.IsCancellationRequested)
            return ValueTask.CompletedTask;

        cancellationTokenSource.Cancel();
        cancellationTokenSource.Dispose();

        List<Task> taskList = new(1);

        if (GenericModuleModule?.IsCompletedSuccessfully == true)
            if (GenericModuleModule.Result is IJSInProcessObjectReference inProcessModule)
                inProcessModule.Dispose();
            else {
                ValueTask valueTask = GenericModuleModule.Result.DisposeAsync();
                if (!valueTask.IsCompleted)
                    taskList.Add(valueTask.AsTask());
            }
        GenericModuleModule = null;

        if (taskList.Count == 0)
            return ValueTask.CompletedTask;
        else
            return new ValueTask(Task.WhenAll(taskList));
    }
}


----------
ITSRuntime
----------

// <auto-generated/>
#pragma warning disable
#nullable enable annotations


using System.Threading;
using System.Threading.Tasks;

namespace Microsoft.JSInterop;

/// <summary>
/// <para>Interface for JS-interop.</para>
/// <para>It contains an invoke-method for every js-function, a preload-method for every module and a method to load all modules.</para>
/// </summary>
[System.CodeDom.Compiler.GeneratedCodeAttribute("Blazor.TSRuntime", "0.6.0")]
public partial interface ITSRuntime {
    /// <summary>
    /// <para>Fetches all modules as javascript-modules.</para>
    /// <para>If already loading, it doesn't trigger a second loading and if any already loaded, these are not loaded again, so if all already loaded, it returns a completed task.</para>
    /// </summary>
    /// <returns>A Task that will complete when all module loading Tasks have completed.</returns>
    public Task PreloadAllModules();
    

    /// <summary>
    /// <para>Invokes the specified JavaScript function in the specified module synchronously.</para>
    /// <para>If module is not loaded, it returns without any invoking. If synchronous is not supported, it fails with an exception.</para>
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="moduleUrl">complete path of the module, e.g. "/Pages/Example.razor.js"</param>
    /// <param name="identifier">name of the javascript function</param>
    /// <param name="success">false when the module is not loaded, otherwise true</param>
    /// <param name="args">parameter passing to the JS-function</param>
    /// <returns>default when the module is not loaded, otherwise result of the JS-function</returns>
    private TResult Invoke<TResult>(Task<IJSObjectReference> moduleTask, string identifier, params object?[]? args) {
        if (!moduleTask.IsCompletedSuccessfully)
            throw new JSException("JS-module is not loaded. Use and await the Preload-method to ensure the module is loaded.");

        return ((IJSInProcessObjectReference)moduleTask.Result).Invoke<TResult>(identifier, args);
    }

    /// <summary>
    /// Invokes the specified JavaScript function in the specified module synchronously when supported, otherwise asynchronously.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="moduleUrl">complete path of the module, e.g. "/Pages/Example.razor.js"</param>
    /// <param name="identifier">name of the javascript function</param>
    /// <param name="cancellationToken">A cancellation token to signal the cancellation of the operation. Specifying this parameter will override any default cancellations such as due to timeouts (<see cref="JSRuntime.DefaultAsyncTimeout"/>) from being applied.</param>
    /// <param name="args">parameter passing to the JS-function</param>
    /// <returns></returns>
    private async ValueTask<TValue> InvokeTrySync<TValue>(Task<IJSObjectReference> moduleTask, string identifier, CancellationToken cancellationToken, params object?[]? args) {
        IJSObjectReference module = await moduleTask;
        if (module is IJSInProcessObjectReference inProcessModule)
            return inProcessModule.Invoke<TValue>(identifier, args);
        else
            return await module.InvokeAsync<TValue>(identifier, cancellationToken, args);
    }

    /// <summary>
    /// Invokes the specified JavaScript function in the specified module asynchronously.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="moduleUrl">complete path of the module, e.g. "/Pages/Example.razor.js"</param>
    /// <param name="identifier">name of the javascript function</param>
    /// <param name="cancellationToken">A cancellation token to signal the cancellation of the operation. Specifying this parameter will override any default cancellations such as due to timeouts (<see cref="JSRuntime.DefaultAsyncTimeout"/>) from being applied.</param>
    /// <param name="args">parameter passing to the JS-function</param>
    /// <returns></returns>
    private async ValueTask<TValue> InvokeAsync<TValue>(Task<IJSObjectReference> moduleTask, string identifier, CancellationToken cancellationToken, params object?[]? args) {
        IJSObjectReference module = await moduleTask;
        return await module.InvokeAsync<TValue>(identifier, cancellationToken, args);
    }
}


------
Module
------

// <auto-generated/>
#pragma warning disable
#nullable enable annotations


using System.Threading;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Components;
using System.Numerics;

namespace Microsoft.JSInterop;

public partial interface ITSRuntime {
    protected Task<IJSObjectReference> GetGenericModuleModule();

    /// <summary>
    /// <para>Loads 'GenericModule' (/GenericModule.js) as javascript-module.</para>
    /// <para>If already loading, it does not trigger a second loading and if already loaded, it returns a completed task.</para>
    /// </summary>
    /// <returns>A Task that will complete when the module import have completed.</returns>
    public Task PreloadGenericModule() => GetGenericModuleModule();


    /// <summary>
    /// <para>Invokes in module 'GenericModule' the JS-function 'genericKeyofConstraint' synchronously when supported, otherwise asynchronously.</para>
    /// </summary>
    /// <param name="cancellationToken">A cancellation token to signal the cancellation of the operation. Specifying this parameter will override any default cancellations such as due to timeouts (<see cref="JSRuntime.DefaultAsyncTimeout"/>) from being applied.</param>
    /// <returns>A Task that will complete when the JS-Function have completed.</returns>
    public Task GenericKeyofConstraint<Type, Key>(CancellationToken cancellationToken = default)
        => InvokeTrySync<Infrastructure.IJSVoidResult>(GetGenericModuleModule(), "genericKeyofConstraint", cancellationToken) switch {
            ValueTask<Infrastructure.IJSVoidResult> { IsCompleted: true } => Task.CompletedTask,
            ValueTask<Infrastructure.IJSVoidResult> task => task.AsTask()
        };
}
