---------
TSRuntime
---------

// <auto-generated/>
#pragma warning disable
#nullable enable annotations


using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;

namespace Microsoft.JSInterop;

/// <summary>
/// <para>An implementation for <see cref="ITSRuntime"/>.</para>
/// <para>It manages JS-modules: It loads the modules, caches it in an array and disposing releases all modules.</para>
/// <para>
/// There is 1 module available: GenericModule
/// </para>
/// </summary>
[System.CodeDom.Compiler.GeneratedCodeAttribute("Blazor.TSRuntime", "1.0.0")]
public sealed class TSRuntime(IJSRuntime jsRuntime) : ITSRuntime, IDisposable, IAsyncDisposable {
    private readonly CancellationTokenSource cancellationTokenSource = new();

    Task<IJSObjectReference> ITSRuntime.GetGenericModuleModule() => GetGenericModuleModule();
    private Task<IJSObjectReference>? GenericModuleModule;
    private Task<IJSObjectReference> GetGenericModuleModule()
        => GenericModuleModule switch {
            Task<IJSObjectReference> { IsCompletedSuccessfully: true }
            or Task<IJSObjectReference> { IsCompleted: false } => GenericModuleModule,
            _ => GenericModuleModule = jsRuntime.InvokeAsync<IJSObjectReference>("import", cancellationTokenSource.Token, "/GenericModule.js").AsTask()
        };

    public Task PreloadAllModules() {
        GetGenericModuleModule();

        return Task.WhenAll([GenericModuleModule!]);
    }


    TResult ITSRuntime.TSInvoke<TResult>(string identifier, object?[]? args) => ((IJSInProcessRuntime)jsRuntime).Invoke<TResult>(identifier, args);

    ValueTask<TResult> ITSRuntime.TSInvokeTrySync<TResult>(string identifier, object?[]? args, CancellationToken cancellationToken) {
        if (jsRuntime is IJSInProcessRuntime jsInProcessRuntime)
            return ValueTask.FromResult(jsInProcessRuntime.Invoke<TResult>(identifier, args));
        else
            return jsRuntime.InvokeAsync<TResult>(identifier, cancellationToken, args);
    }

    ValueTask<TResult> ITSRuntime.TSInvokeAsync<TResult>(string identifier, object?[]? args, CancellationToken cancellationToken)
        => jsRuntime.InvokeAsync<TResult>(identifier, cancellationToken, args);


    TResult ITSRuntime.TSInvoke<TResult>(Task<IJSObjectReference> moduleTask, string identifier, object?[]? args) {
        if (!moduleTask.IsCompletedSuccessfully)
            throw new JSException("JS-module is not loaded. Use and await the Preload()-method to ensure the module is loaded.");

        return ((IJSInProcessObjectReference)moduleTask.Result).Invoke<TResult>(identifier, args);
    }

    async ValueTask<TResult> ITSRuntime.TSInvokeTrySync<TResult>(Task<IJSObjectReference> moduleTask, string identifier, object?[]? args, CancellationToken cancellationToken) {
        IJSObjectReference module = await moduleTask;
        if (module is IJSInProcessObjectReference inProcessModule)
            return inProcessModule.Invoke<TResult>(identifier, args);
        else
            return await module.InvokeAsync<TResult>(identifier, cancellationToken, args);
    }

    async ValueTask<TResult> ITSRuntime.TSInvokeAsync<TResult>(Task<IJSObjectReference> moduleTask, string identifier, object?[]? args, CancellationToken cancellationToken) {
        IJSObjectReference module = await moduleTask;
        return await module.InvokeAsync<TResult>(identifier, cancellationToken, args);
    }

    
    TResult ITSRuntime.TSInvoke<TResult, TCallback>(string identifier, DotNetObjectReference<TCallback> dotNetObjectReference, object?[]? args) where TCallback : class => default; // no callbacks are used

    ValueTask<TResult> ITSRuntime.TSInvokeTrySync<TResult, TCallback>(string identifier, DotNetObjectReference<TCallback> dotNetObjectReference, object?[]? args, CancellationToken cancellationToken) where TCallback : class => default; // no callbacks are used

    ValueTask<TResult> ITSRuntime.TSInvokeAsync<TResult, TCallback>(string identifier, DotNetObjectReference<TCallback> dotNetObjectReference, object?[]? args, CancellationToken cancellationToken) where TCallback : class => default; // no callbacks are used


    TResult ITSRuntime.TSInvoke<TResult, TCallback>(Task<IJSObjectReference> moduleTask, string identifier, DotNetObjectReference<TCallback> dotNetObjectReference, object?[]? args) where TCallback : class  => default; // no callbacks are used

    ValueTask<TResult> ITSRuntime.TSInvokeTrySync<TResult, TCallback>(Task<IJSObjectReference> moduleTask, string identifier, DotNetObjectReference<TCallback> dotNetObjectReference, object?[]? args, CancellationToken cancellationToken) where TCallback : class  => default; // no callbacks are used

    ValueTask<TResult> ITSRuntime.TSInvokeAsync<TResult, TCallback>(Task<IJSObjectReference> moduleTask, string identifier, DotNetObjectReference<TCallback> dotNetObjectReference, object?[]? args, CancellationToken cancellationToken) where TCallback : class => default; // no callbacks are used



    /// <summary>
    /// Releases each module synchronously if possible, otherwise asynchronously per fire and forget.
    /// </summary>
    public void Dispose() {
        if (cancellationTokenSource.IsCancellationRequested)
            return;

        cancellationTokenSource.Cancel();
        cancellationTokenSource.Dispose();

        if (GenericModuleModule?.IsCompletedSuccessfully == true)
            if (GenericModuleModule.Result is IJSInProcessObjectReference inProcessModule)
                inProcessModule.Dispose();
            else
                _ = GenericModuleModule.Result.DisposeAsync().Preserve();
        GenericModuleModule = null;
    }

    /// <summary>
    /// <para>Releases each module synchronously if possible, otherwise asynchronously and returns a task that completes, when all module disposing tasks complete.</para>
    /// <para>The asynchronous disposing tasks are happening in parallel.</para>
    /// </summary>
    /// <returns></returns>
    public ValueTask DisposeAsync() {
        if (cancellationTokenSource.IsCancellationRequested)
            return ValueTask.CompletedTask;

        cancellationTokenSource.Cancel();
        cancellationTokenSource.Dispose();

        List<Task> taskList = new(1);

        if (GenericModuleModule?.IsCompletedSuccessfully == true)
            if (GenericModuleModule.Result is IJSInProcessObjectReference inProcessModule)
                inProcessModule.Dispose();
            else {
                ValueTask valueTask = GenericModuleModule.Result.DisposeAsync();
                if (!valueTask.IsCompleted)
                    taskList.Add(valueTask.AsTask());
            }
        GenericModuleModule = null;

        if (taskList.Count == 0)
            return ValueTask.CompletedTask;
        else
            return new ValueTask(Task.WhenAll(taskList));
    }
}


----------
ITSRuntime
----------

// <auto-generated/>
#pragma warning disable
#nullable enable annotations


using System.Threading;
using System.Threading.Tasks;

namespace Microsoft.JSInterop;

/// <summary>
/// <para>Interface for JS-interop.</para>
/// <para>It contains an invoke-method for every js-function, a preload-method for every module and a method to load all modules.</para>
/// </summary>
[System.CodeDom.Compiler.GeneratedCodeAttribute("Blazor.TSRuntime", "1.0.0")]
public partial interface ITSRuntime {
    /// <summary>
    /// <para>Fetches all modules as javascript-modules.</para>
    /// <para>If already loading, it doesn't trigger a second loading and if any already loaded, these are not loaded again, so if all already loaded, it returns a completed task.</para>
    /// </summary>
    /// <returns>A Task that will complete when all module loading Tasks have completed.</returns>
    public Task PreloadAllModules();



    /// <summary>
    /// <para>Invokes the specified JavaScript function synchronously.</para>
    /// <para>If module is not loaded or synchronous is not supported, it fails with an exception.</para>
    /// </summary>
    /// <typeparam name="TResult"></typeparam>
    /// <param name="identifier">name of the javascript function</param>
    /// <param name="args">parameter passing to the JS-function</param>
    /// <returns></returns>
    protected TResult TSInvoke<TResult>(string identifier, object?[]? args);

    /// <summary>
    /// Invokes the specified JavaScript function synchronously when supported, otherwise asynchronously.
    /// </summary>
    /// <typeparam name="TResult"></typeparam>
    /// <param name="identifier">name of the javascript function</param>
    /// <param name="args">parameter passing to the JS-function</param>
    /// <param name="cancellationToken">A cancellation token to signal the cancellation of the operation. Specifying this parameter will override any default cancellations such as due to timeouts (<see cref="JSRuntime.DefaultAsyncTimeout"/>) from being applied.</param>
    /// <returns></returns>
    protected ValueTask<TResult> TSInvokeTrySync<TResult>(string identifier, object?[]? args, CancellationToken cancellationToken);

    /// <summary>
    /// Invokes the specified JavaScript function asynchronously.
    /// </summary>
    /// <typeparam name="TResult"></typeparam>
    /// <param name="identifier">name of the javascript function</param>
    /// <param name="args">parameter passing to the JS-function</param>
    /// <param name="cancellationToken">A cancellation token to signal the cancellation of the operation. Specifying this parameter will override any default cancellations such as due to timeouts (<see cref="JSRuntime.DefaultAsyncTimeout"/>) from being applied.</param>
    /// <returns></returns>
    protected ValueTask<TResult> TSInvokeAsync<TResult>(string identifier, object?[]? args, CancellationToken cancellationToken);


    /// <summary>
    /// <para>Invokes the specified JavaScript function in the specified module synchronously.</para>
    /// <para>If module is not loaded or synchronous is not supported, it fails with an exception.</para>
    /// </summary>
    /// <typeparam name="TResult"></typeparam>
    /// <param name="moduleTask">The loading task of a module</param>
    /// <param name="identifier">name of the javascript function</param>
    /// <param name="args">parameter passing to the JS-function</param>
    /// <returns></returns>
    protected TResult TSInvoke<TResult>(Task<IJSObjectReference> moduleTask, string identifier, object?[]? args);

    /// <summary>
    /// Invokes the specified JavaScript function in the specified module synchronously when supported, otherwise asynchronously.
    /// </summary>
    /// <typeparam name="TResult"></typeparam>
    /// <param name="moduleTask">The loading task of a module</param>
    /// <param name="identifier">name of the javascript function</param>
    /// <param name="args">parameter passing to the JS-function</param>
    /// <param name="cancellationToken">A cancellation token to signal the cancellation of the operation. Specifying this parameter will override any default cancellations such as due to timeouts (<see cref="JSRuntime.DefaultAsyncTimeout"/>) from being applied.</param>
    /// <returns></returns>
    protected ValueTask<TResult> TSInvokeTrySync<TResult>(Task<IJSObjectReference> moduleTask, string identifier, object?[]? args, CancellationToken cancellationToken);

    /// <summary>
    /// Invokes the specified JavaScript function in the specified module asynchronously.
    /// </summary>
    /// <typeparam name="TResult"></typeparam>
    /// <param name="moduleTask">The loading task of a module</param>
    /// <param name="identifier">name of the javascript function</param>
    /// <param name="args">parameter passing to the JS-function</param>
    /// <param name="cancellationToken">A cancellation token to signal the cancellation of the operation. Specifying this parameter will override any default cancellations such as due to timeouts (<see cref="JSRuntime.DefaultAsyncTimeout"/>) from being applied.</param>
    /// <returns></returns>
    protected ValueTask<TResult> TSInvokeAsync<TResult>(Task<IJSObjectReference> moduleTask, string identifier, object?[]? args, CancellationToken cancellationToken);


    /// <summary>
    /// <para>Invokes the specified JavaScript function synchronously.</para>
    /// <para>If module is not loaded or synchronous is not supported, it fails with an exception.</para>
    /// </summary>
    /// <typeparam name="TResult"></typeparam>
    /// <typeparam name="TCallback"></typeparam>
    /// <param name="identifier">name of the javascript function</param>
    /// <param name="dotNetObjectReference">reference to a csharp object with callback functions</param>
    /// <param name="args">parameter passing to the JS-function</param>
    /// <returns></returns>
    protected TResult TSInvoke<TResult, TCallback>(string identifier, DotNetObjectReference<TCallback> dotNetObjectReference, object?[]? args) where TCallback : class;

    /// <summary>
    /// Invokes the specified JavaScript function synchronously when supported, otherwise asynchronously.
    /// </summary>
    /// <typeparam name="TResult"></typeparam>
    /// <typeparam name="TCallback"></typeparam>
    /// <param name="identifier">name of the javascript function</param>
    /// <param name="dotNetObjectReference">reference to a csharp object with callback functions</param>
    /// <param name="args">parameter passing to the JS-function</param>
    /// <param name="cancellationToken">A cancellation token to signal the cancellation of the operation. Specifying this parameter will override any default cancellations such as due to timeouts (<see cref="JSRuntime.DefaultAsyncTimeout"/>) from being applied.</param>
    /// <returns></returns>
    protected ValueTask<TResult> TSInvokeTrySync<TResult, TCallback>(string identifier, DotNetObjectReference<TCallback> dotNetObjectReference, object?[]? args, CancellationToken cancellationToken) where TCallback : class;

    /// <summary>
    /// Invokes the specified JavaScript function asynchronously.
    /// </summary>
    /// <typeparam name="TResult"></typeparam>
    /// <typeparam name="TCallback"></typeparam>
    /// <param name="identifier">name of the javascript function</param>
    /// <param name="dotNetObjectReference">reference to a csharp object with callback functions</param>
    /// <param name="args">parameter passing to the JS-function</param>
    /// <param name="cancellationToken">A cancellation token to signal the cancellation of the operation. Specifying this parameter will override any default cancellations such as due to timeouts (<see cref="JSRuntime.DefaultAsyncTimeout"/>) from being applied.</param>
    /// <returns></returns>
    protected ValueTask<TResult> TSInvokeAsync<TResult, TCallback>(string identifier, DotNetObjectReference<TCallback> dotNetObjectReference, object?[]? args, CancellationToken cancellationToken) where TCallback : class;


    /// <summary>
    /// <para>Invokes the specified JavaScript function in the specified module synchronously.</para>
    /// <para>If module is not loaded or synchronous is not supported, it fails with an exception.</para>
    /// </summary>
    /// <typeparam name="TResult"></typeparam>
    /// <typeparam name="TCallback"></typeparam>
    /// <param name="moduleTask">The loading task of a module</param>
    /// <param name="identifier">name of the javascript function</param>
    /// <param name="dotNetObjectReference">reference to a csharp object with callback functions</param>
    /// <param name="args">parameter passing to the JS-function</param>
    /// <returns></returns>
    protected TResult TSInvoke<TResult, TCallback>(Task<IJSObjectReference> moduleTask, string identifier, DotNetObjectReference<TCallback> dotNetObjectReference, object?[]? args) where TCallback : class;

    /// <summary>
    /// Invokes the specified JavaScript function in the specified module synchronously when supported, otherwise asynchronously.
    /// </summary>
    /// <typeparam name="TResult"></typeparam>
    /// <typeparam name="TCallback"></typeparam>
    /// <param name="moduleTask">The loading task of a module</param>
    /// <param name="identifier">name of the javascript function</param>
    /// <param name="dotNetObjectReference">reference to a csharp object with callback functions</param>
    /// <param name="args">parameter passing to the JS-function</param>
    /// <param name="cancellationToken">A cancellation token to signal the cancellation of the operation. Specifying this parameter will override any default cancellations such as due to timeouts (<see cref="JSRuntime.DefaultAsyncTimeout"/>) from being applied.</param>
    /// <returns></returns>
    protected ValueTask<TResult> TSInvokeTrySync<TResult, TCallback>(Task<IJSObjectReference> moduleTask, string identifier, DotNetObjectReference<TCallback> dotNetObjectReference, object?[]? args, CancellationToken cancellationToken) where TCallback : class;

    /// <summary>
    /// Invokes the specified JavaScript function in the specified module asynchronously.
    /// </summary>
    /// <typeparam name="TResult"></typeparam>
    /// <typeparam name="TCallback"></typeparam>
    /// <param name="moduleTask">The loading task of a module</param>
    /// <param name="identifier">name of the javascript function</param>
    /// <param name="dotNetObjectReference">reference to a csharp object with callback functions</param>
    /// <param name="args">parameter passing to the JS-function</param>
    /// <param name="cancellationToken">A cancellation token to signal the cancellation of the operation. Specifying this parameter will override any default cancellations such as due to timeouts (<see cref="JSRuntime.DefaultAsyncTimeout"/>) from being applied.</param>
    /// <returns></returns>
    protected ValueTask<TResult> TSInvokeAsync<TResult, TCallback>(Task<IJSObjectReference> moduleTask, string identifier, DotNetObjectReference<TCallback> dotNetObjectReference, object?[]? args, CancellationToken cancellationToken) where TCallback : class;
}


------
Module
------

// <auto-generated/>
#pragma warning disable
#nullable enable annotations


using System.Threading;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Components;
using System.Numerics;

namespace Microsoft.JSInterop;

public partial interface ITSRuntime {
    protected Task<IJSObjectReference> GetGenericModuleModule();

    /// <summary>
    /// <para>Loads 'GenericModule' (/GenericModule.js) as javascript-module.</para>
    /// <para>If already loading, it does not trigger a second loading and if already loaded, it returns a completed task.</para>
    /// </summary>
    /// <returns>A Task that will complete when the module import have completed.</returns>
    public Task PreloadGenericModule() => GetGenericModuleModule();


    /// <summary>
    /// <para>Invokes in module 'GenericModule' the JS-function 'generic' synchronously when supported, otherwise asynchronously.</para>
    /// </summary>
    /// <typeparam name="A"></typeparam>
    /// <typeparam name="B"></typeparam>
    /// <typeparam name="C"></typeparam>
    /// <param name="cancellationToken">A cancellation token to signal the cancellation of the operation. Specifying this parameter will override any default cancellations such as due to timeouts (<see cref="JSRuntime.DefaultAsyncTimeout"/>) from being applied.</param>
    /// <returns>Result of the JS-function.</returns>
    public async ValueTask<A> Generic<A, B, C>(CancellationToken cancellationToken = default) {
        return await TSInvokeTrySync<A>(GetGenericModuleModule(), "generic", [], cancellationToken);
    }
}
