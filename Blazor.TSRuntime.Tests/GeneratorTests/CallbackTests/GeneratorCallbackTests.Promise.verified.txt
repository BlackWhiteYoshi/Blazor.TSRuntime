---------
TSRuntime
---------

// <auto-generated/>
#pragma warning disable
#nullable enable annotations


using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;

namespace Microsoft.JSInterop;

/// <summary>
/// <para>An implementation for <see cref="ITSRuntime"/>.</para>
/// <para>It manages JS-modules: It loads the modules, caches it in an array and disposing releases all modules.</para>
/// <para>
/// There is 1 module available: site
/// </para>
/// </summary>
[System.CodeDom.Compiler.GeneratedCodeAttribute("Blazor.TSRuntime", "1.0.1")]
public sealed class TSRuntime(IJSRuntime jsRuntime) : ITSRuntime, IDisposable, IAsyncDisposable {
    private readonly CancellationTokenSource cancellationTokenSource = new();

    private Task<IJSObjectReference>? callbackModule;
    private Task<IJSObjectReference> CallbackModule => callbackModule ??= jsRuntime.InvokeAsync<IJSObjectReference>("import", "data:text/javascript,export function callbackTest(__module,__callback){return __module.callbackTest(()=>__callback.invokeMethodAsync('someCallback'));}").AsTask();

    Task<IJSObjectReference> ITSRuntime.GetsiteModule() => GetsiteModule();
    private Task<IJSObjectReference>? siteModule;
    private Task<IJSObjectReference> GetsiteModule()
        => siteModule switch {
            Task<IJSObjectReference> { IsCompletedSuccessfully: true }
            or Task<IJSObjectReference> { IsCompleted: false } => siteModule,
            _ => siteModule = jsRuntime.InvokeAsync<IJSObjectReference>("import", cancellationTokenSource.Token, "/site.js").AsTask()
        };

    public Task PreloadAllModules() {
        GetsiteModule();

        return Task.WhenAll([CallbackModule, siteModule!]);
    }


    TResult ITSRuntime.TSInvoke<TResult>(string identifier, object?[]? args) => ((IJSInProcessRuntime)jsRuntime).Invoke<TResult>(identifier, args);

    ValueTask<TResult> ITSRuntime.TSInvokeTrySync<TResult>(string identifier, object?[]? args, CancellationToken cancellationToken) {
        if (jsRuntime is IJSInProcessRuntime jsInProcessRuntime)
            return ValueTask.FromResult(jsInProcessRuntime.Invoke<TResult>(identifier, args));
        else
            return jsRuntime.InvokeAsync<TResult>(identifier, cancellationToken, args);
    }

    ValueTask<TResult> ITSRuntime.TSInvokeAsync<TResult>(string identifier, object?[]? args, CancellationToken cancellationToken)
        => jsRuntime.InvokeAsync<TResult>(identifier, cancellationToken, args);


    TResult ITSRuntime.TSInvoke<TResult>(Task<IJSObjectReference> moduleTask, string identifier, object?[]? args) {
        if (!moduleTask.IsCompletedSuccessfully)
            throw new JSException("JS-module is not loaded. Use and await the Preload()-method to ensure the module is loaded.");

        return ((IJSInProcessObjectReference)moduleTask.Result).Invoke<TResult>(identifier, args);
    }

    async ValueTask<TResult> ITSRuntime.TSInvokeTrySync<TResult>(Task<IJSObjectReference> moduleTask, string identifier, object?[]? args, CancellationToken cancellationToken) {
        IJSObjectReference module = await moduleTask;
        if (module is IJSInProcessObjectReference inProcessModule)
            return inProcessModule.Invoke<TResult>(identifier, args);
        else
            return await module.InvokeAsync<TResult>(identifier, cancellationToken, args);
    }

    async ValueTask<TResult> ITSRuntime.TSInvokeAsync<TResult>(Task<IJSObjectReference> moduleTask, string identifier, object?[]? args, CancellationToken cancellationToken) {
        IJSObjectReference module = await moduleTask;
        return await module.InvokeAsync<TResult>(identifier, cancellationToken, args);
    }


    TResult ITSRuntime.TSInvoke<TResult, TCallback>(string identifier, DotNetObjectReference<TCallback> dotNetObjectReference, object?[]? args) where TCallback : class {
        if (!CallbackModule.IsCompletedSuccessfully)
            throw new JSException("JS-module is not loaded. Use and await the Preload()-method to ensure the module is loaded.");

        return ((IJSInProcessObjectReference)CallbackModule.Result).Invoke<TResult>(identifier, [dotNetObjectReference, .. args]);
    }

    async ValueTask<TResult> ITSRuntime.TSInvokeTrySync<TResult, TCallback>(string identifier, DotNetObjectReference<TCallback> dotNetObjectReference, object?[]? args, CancellationToken cancellationToken) where TCallback : class {
        IJSObjectReference module = await CallbackModule;
        if (module is IJSInProcessObjectReference inProcessModule)
            return inProcessModule.Invoke<TResult>(identifier, [dotNetObjectReference, .. args]);
        else
            return await module.InvokeAsync<TResult>(identifier, cancellationToken, [dotNetObjectReference, .. args]);
    }

    async ValueTask<TResult> ITSRuntime.TSInvokeAsync<TResult, TCallback>(string identifier, DotNetObjectReference<TCallback> dotNetObjectReference, object?[]? args, CancellationToken cancellationToken) where TCallback : class {
        IJSObjectReference module = await CallbackModule;
        return await module.InvokeAsync<TResult>(identifier, cancellationToken, [dotNetObjectReference, .. args]);
    }


    TResult ITSRuntime.TSInvoke<TResult, TCallback>(Task<IJSObjectReference> moduleTask, string identifier, DotNetObjectReference<TCallback> dotNetObjectReference, object?[]? args) where TCallback : class {
        if (!moduleTask.IsCompletedSuccessfully || !CallbackModule.IsCompletedSuccessfully)
            throw new JSException("JS-module is not loaded. Use and await the Preload()-method to ensure the module is loaded.");

        return ((IJSInProcessObjectReference)CallbackModule.Result).Invoke<TResult>(identifier, [moduleTask.Result, dotNetObjectReference, .. args]);
    }

    async ValueTask<TResult> ITSRuntime.TSInvokeTrySync<TResult, TCallback>(Task<IJSObjectReference> moduleTask, string identifier, DotNetObjectReference<TCallback> dotNetObjectReference, object?[]? args, CancellationToken cancellationToken) where TCallback : class {
        IJSObjectReference module = await CallbackModule;
        if (module is IJSInProcessObjectReference inProcessModule)
            return inProcessModule.Invoke<TResult>(identifier, [await moduleTask, dotNetObjectReference, .. args]);
        else
            return await module.InvokeAsync<TResult>(identifier, cancellationToken, [await moduleTask, dotNetObjectReference, .. args]);
    }

    async ValueTask<TResult> ITSRuntime.TSInvokeAsync<TResult, TCallback>(Task<IJSObjectReference> moduleTask, string identifier, DotNetObjectReference<TCallback> dotNetObjectReference, object?[]? args, CancellationToken cancellationToken) where TCallback : class {
        IJSObjectReference module = await CallbackModule;
        return await module.InvokeAsync<TResult>(identifier, cancellationToken, [await moduleTask, dotNetObjectReference, .. args]);
    }



    /// <summary>
    /// Releases each module synchronously if possible, otherwise asynchronously per fire and forget.
    /// </summary>
    public void Dispose() {
        if (cancellationTokenSource.IsCancellationRequested)
            return;

        cancellationTokenSource.Cancel();
        cancellationTokenSource.Dispose();

        if (siteModule?.IsCompletedSuccessfully == true)
            if (siteModule.Result is IJSInProcessObjectReference inProcessModule)
                inProcessModule.Dispose();
            else
                _ = siteModule.Result.DisposeAsync().Preserve();
        siteModule = null;

        if (callbackModule?.IsCompletedSuccessfully == true)
            if (callbackModule.Result is IJSInProcessObjectReference inProcessModule)
                inProcessModule.Dispose();
            else
                _ = callbackModule.Result.DisposeAsync().Preserve();
        callbackModule = null;
    }

    /// <summary>
    /// <para>Releases each module synchronously if possible, otherwise asynchronously and returns a task that completes, when all module disposing tasks complete.</para>
    /// <para>The asynchronous disposing tasks are happening in parallel.</para>
    /// </summary>
    /// <returns></returns>
    public ValueTask DisposeAsync() {
        if (cancellationTokenSource.IsCancellationRequested)
            return ValueTask.CompletedTask;

        cancellationTokenSource.Cancel();
        cancellationTokenSource.Dispose();

        List<Task> taskList = new(1);

        if (siteModule?.IsCompletedSuccessfully == true)
            if (siteModule.Result is IJSInProcessObjectReference inProcessModule)
                inProcessModule.Dispose();
            else {
                ValueTask valueTask = siteModule.Result.DisposeAsync();
                if (!valueTask.IsCompleted)
                    taskList.Add(valueTask.AsTask());
            }
        siteModule = null;

        if (callbackModule?.IsCompletedSuccessfully == true)
            if (callbackModule.Result is IJSInProcessObjectReference inProcessModule)
                inProcessModule.Dispose();
            else {
                ValueTask valueTask = callbackModule.Result.DisposeAsync();
                if (!valueTask.IsCompleted)
                    taskList.Add(valueTask.AsTask());
            }
        callbackModule = null;

        if (taskList.Count == 0)
            return ValueTask.CompletedTask;
        else
            return new ValueTask(Task.WhenAll(taskList));
    }
}


----------
ITSRuntime
----------

// <auto-generated/>
#pragma warning disable
#nullable enable annotations


using System.Threading;
using System.Threading.Tasks;

namespace Microsoft.JSInterop;

/// <summary>
/// <para>Interface for JS-interop.</para>
/// <para>It contains an invoke-method for every js-function, a preload-method for every module and a method to load all modules.</para>
/// </summary>
[System.CodeDom.Compiler.GeneratedCodeAttribute("Blazor.TSRuntime", "1.0.1")]
public partial interface ITSRuntime {
    /// <summary>
    /// <para>Fetches all modules as javascript-modules.</para>
    /// <para>If already loading, it doesn't trigger a second loading and if any already loaded, these are not loaded again, so if all already loaded, it returns a completed task.</para>
    /// </summary>
    /// <returns>A Task that will complete when all module loading Tasks have completed.</returns>
    public Task PreloadAllModules();



    /// <summary>
    /// <para>Invokes the specified JavaScript function synchronously.</para>
    /// <para>If module is not loaded or synchronous is not supported, it fails with an exception.</para>
    /// </summary>
    /// <typeparam name="TResult"></typeparam>
    /// <param name="identifier">name of the javascript function</param>
    /// <param name="args">parameter passing to the JS-function</param>
    /// <returns></returns>
    protected TResult TSInvoke<TResult>(string identifier, object?[]? args);

    /// <summary>
    /// Invokes the specified JavaScript function synchronously when supported, otherwise asynchronously.
    /// </summary>
    /// <typeparam name="TResult"></typeparam>
    /// <param name="identifier">name of the javascript function</param>
    /// <param name="args">parameter passing to the JS-function</param>
    /// <param name="cancellationToken">A cancellation token to signal the cancellation of the operation. Specifying this parameter will override any default cancellations such as due to timeouts (<see cref="JSRuntime.DefaultAsyncTimeout"/>) from being applied.</param>
    /// <returns></returns>
    protected ValueTask<TResult> TSInvokeTrySync<TResult>(string identifier, object?[]? args, CancellationToken cancellationToken);

    /// <summary>
    /// Invokes the specified JavaScript function asynchronously.
    /// </summary>
    /// <typeparam name="TResult"></typeparam>
    /// <param name="identifier">name of the javascript function</param>
    /// <param name="args">parameter passing to the JS-function</param>
    /// <param name="cancellationToken">A cancellation token to signal the cancellation of the operation. Specifying this parameter will override any default cancellations such as due to timeouts (<see cref="JSRuntime.DefaultAsyncTimeout"/>) from being applied.</param>
    /// <returns></returns>
    protected ValueTask<TResult> TSInvokeAsync<TResult>(string identifier, object?[]? args, CancellationToken cancellationToken);


    /// <summary>
    /// <para>Invokes the specified JavaScript function in the specified module synchronously.</para>
    /// <para>If module is not loaded or synchronous is not supported, it fails with an exception.</para>
    /// </summary>
    /// <typeparam name="TResult"></typeparam>
    /// <param name="moduleTask">The loading task of a module</param>
    /// <param name="identifier">name of the javascript function</param>
    /// <param name="args">parameter passing to the JS-function</param>
    /// <returns></returns>
    protected TResult TSInvoke<TResult>(Task<IJSObjectReference> moduleTask, string identifier, object?[]? args);

    /// <summary>
    /// Invokes the specified JavaScript function in the specified module synchronously when supported, otherwise asynchronously.
    /// </summary>
    /// <typeparam name="TResult"></typeparam>
    /// <param name="moduleTask">The loading task of a module</param>
    /// <param name="identifier">name of the javascript function</param>
    /// <param name="args">parameter passing to the JS-function</param>
    /// <param name="cancellationToken">A cancellation token to signal the cancellation of the operation. Specifying this parameter will override any default cancellations such as due to timeouts (<see cref="JSRuntime.DefaultAsyncTimeout"/>) from being applied.</param>
    /// <returns></returns>
    protected ValueTask<TResult> TSInvokeTrySync<TResult>(Task<IJSObjectReference> moduleTask, string identifier, object?[]? args, CancellationToken cancellationToken);

    /// <summary>
    /// Invokes the specified JavaScript function in the specified module asynchronously.
    /// </summary>
    /// <typeparam name="TResult"></typeparam>
    /// <param name="moduleTask">The loading task of a module</param>
    /// <param name="identifier">name of the javascript function</param>
    /// <param name="args">parameter passing to the JS-function</param>
    /// <param name="cancellationToken">A cancellation token to signal the cancellation of the operation. Specifying this parameter will override any default cancellations such as due to timeouts (<see cref="JSRuntime.DefaultAsyncTimeout"/>) from being applied.</param>
    /// <returns></returns>
    protected ValueTask<TResult> TSInvokeAsync<TResult>(Task<IJSObjectReference> moduleTask, string identifier, object?[]? args, CancellationToken cancellationToken);


    /// <summary>
    /// <para>Invokes the specified JavaScript function synchronously.</para>
    /// <para>If module is not loaded or synchronous is not supported, it fails with an exception.</para>
    /// </summary>
    /// <typeparam name="TResult"></typeparam>
    /// <typeparam name="TCallback"></typeparam>
    /// <param name="identifier">name of the javascript function</param>
    /// <param name="dotNetObjectReference">reference to a csharp object with callback functions</param>
    /// <param name="args">parameter passing to the JS-function</param>
    /// <returns></returns>
    protected TResult TSInvoke<TResult, TCallback>(string identifier, DotNetObjectReference<TCallback> dotNetObjectReference, object?[]? args) where TCallback : class;

    /// <summary>
    /// Invokes the specified JavaScript function synchronously when supported, otherwise asynchronously.
    /// </summary>
    /// <typeparam name="TResult"></typeparam>
    /// <typeparam name="TCallback"></typeparam>
    /// <param name="identifier">name of the javascript function</param>
    /// <param name="dotNetObjectReference">reference to a csharp object with callback functions</param>
    /// <param name="args">parameter passing to the JS-function</param>
    /// <param name="cancellationToken">A cancellation token to signal the cancellation of the operation. Specifying this parameter will override any default cancellations such as due to timeouts (<see cref="JSRuntime.DefaultAsyncTimeout"/>) from being applied.</param>
    /// <returns></returns>
    protected ValueTask<TResult> TSInvokeTrySync<TResult, TCallback>(string identifier, DotNetObjectReference<TCallback> dotNetObjectReference, object?[]? args, CancellationToken cancellationToken) where TCallback : class;

    /// <summary>
    /// Invokes the specified JavaScript function asynchronously.
    /// </summary>
    /// <typeparam name="TResult"></typeparam>
    /// <typeparam name="TCallback"></typeparam>
    /// <param name="identifier">name of the javascript function</param>
    /// <param name="dotNetObjectReference">reference to a csharp object with callback functions</param>
    /// <param name="args">parameter passing to the JS-function</param>
    /// <param name="cancellationToken">A cancellation token to signal the cancellation of the operation. Specifying this parameter will override any default cancellations such as due to timeouts (<see cref="JSRuntime.DefaultAsyncTimeout"/>) from being applied.</param>
    /// <returns></returns>
    protected ValueTask<TResult> TSInvokeAsync<TResult, TCallback>(string identifier, DotNetObjectReference<TCallback> dotNetObjectReference, object?[]? args, CancellationToken cancellationToken) where TCallback : class;


    /// <summary>
    /// <para>Invokes the specified JavaScript function in the specified module synchronously.</para>
    /// <para>If module is not loaded or synchronous is not supported, it fails with an exception.</para>
    /// </summary>
    /// <typeparam name="TResult"></typeparam>
    /// <typeparam name="TCallback"></typeparam>
    /// <param name="moduleTask">The loading task of a module</param>
    /// <param name="identifier">name of the javascript function</param>
    /// <param name="dotNetObjectReference">reference to a csharp object with callback functions</param>
    /// <param name="args">parameter passing to the JS-function</param>
    /// <returns></returns>
    protected TResult TSInvoke<TResult, TCallback>(Task<IJSObjectReference> moduleTask, string identifier, DotNetObjectReference<TCallback> dotNetObjectReference, object?[]? args) where TCallback : class;

    /// <summary>
    /// Invokes the specified JavaScript function in the specified module synchronously when supported, otherwise asynchronously.
    /// </summary>
    /// <typeparam name="TResult"></typeparam>
    /// <typeparam name="TCallback"></typeparam>
    /// <param name="moduleTask">The loading task of a module</param>
    /// <param name="identifier">name of the javascript function</param>
    /// <param name="dotNetObjectReference">reference to a csharp object with callback functions</param>
    /// <param name="args">parameter passing to the JS-function</param>
    /// <param name="cancellationToken">A cancellation token to signal the cancellation of the operation. Specifying this parameter will override any default cancellations such as due to timeouts (<see cref="JSRuntime.DefaultAsyncTimeout"/>) from being applied.</param>
    /// <returns></returns>
    protected ValueTask<TResult> TSInvokeTrySync<TResult, TCallback>(Task<IJSObjectReference> moduleTask, string identifier, DotNetObjectReference<TCallback> dotNetObjectReference, object?[]? args, CancellationToken cancellationToken) where TCallback : class;

    /// <summary>
    /// Invokes the specified JavaScript function in the specified module asynchronously.
    /// </summary>
    /// <typeparam name="TResult"></typeparam>
    /// <typeparam name="TCallback"></typeparam>
    /// <param name="moduleTask">The loading task of a module</param>
    /// <param name="identifier">name of the javascript function</param>
    /// <param name="dotNetObjectReference">reference to a csharp object with callback functions</param>
    /// <param name="args">parameter passing to the JS-function</param>
    /// <param name="cancellationToken">A cancellation token to signal the cancellation of the operation. Specifying this parameter will override any default cancellations such as due to timeouts (<see cref="JSRuntime.DefaultAsyncTimeout"/>) from being applied.</param>
    /// <returns></returns>
    protected ValueTask<TResult> TSInvokeAsync<TResult, TCallback>(Task<IJSObjectReference> moduleTask, string identifier, DotNetObjectReference<TCallback> dotNetObjectReference, object?[]? args, CancellationToken cancellationToken) where TCallback : class;
}


------
Module
------

// <auto-generated/>
#pragma warning disable
#nullable enable annotations


using System.Threading;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Components;
using System.Numerics;

namespace Microsoft.JSInterop;

public partial interface ITSRuntime {
    protected Task<IJSObjectReference> GetsiteModule();

    /// <summary>
    /// <para>Loads 'site' (/site.js) as javascript-module.</para>
    /// <para>If already loading, it does not trigger a second loading and if already loaded, it returns a completed task.</para>
    /// </summary>
    /// <returns>A Task that will complete when the module import have completed.</returns>
    public Task PreloadSite() => GetsiteModule();


    [method: DynamicDependency(nameof(_someCallback))]
    private sealed class CallbackTestCallback {
        public Func<ValueTask<string>> _someCallback;
        [JSInvokable] public ValueTask<string> someCallback() => _someCallback();
    }
    /// <summary>
    /// <para>Invokes in module 'site' the JS-function 'callbackTest' synchronously when supported, otherwise asynchronously.</para>
    /// </summary>
    /// <param name="someCallback"></param>
    /// <param name="cancellationToken">A cancellation token to signal the cancellation of the operation. Specifying this parameter will override any default cancellations such as due to timeouts (<see cref="JSRuntime.DefaultAsyncTimeout"/>) from being applied.</param>
    /// <returns>A Task that will complete when the JS-Function have completed.</returns>
    public async ValueTask CallbackTest(Func<ValueTask<string>>? someCallback, CancellationToken cancellationToken = default) {
        using DotNetObjectReference<CallbackTestCallback> __callback = DotNetObjectReference.Create(new CallbackTestCallback() { _someCallback = someCallback });
        await TSInvokeTrySync<Infrastructure.IJSVoidResult, CallbackTestCallback>(GetsiteModule(), "callbackTest", __callback, [], cancellationToken);
    }
}
