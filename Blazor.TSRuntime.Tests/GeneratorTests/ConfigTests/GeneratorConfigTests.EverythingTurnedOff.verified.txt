---------
TSRuntime
---------

// <auto-generated/>
#pragma warning disable
#nullable enable annotations


using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;

namespace Microsoft.JSInterop;

/// <summary>
/// <para>An implementation for <see cref="ITSRuntime"/>.</para>
/// <para>It manages JS-modules: It loads the modules, caches it in an array and disposing releases all modules.</para>
/// <para>
/// There are 2 modules available:<br />
/// - TestModule<br />
/// - NestedTestModule
/// </para>
/// </summary>
[System.CodeDom.Compiler.GeneratedCodeAttribute("Blazor.TSRuntime", "0.6.0")]
public sealed class TSRuntime(IJSRuntime jsRuntime) : ITSRuntime, IDisposable, IAsyncDisposable {
    private readonly CancellationTokenSource cancellationTokenSource = new();

    Task<IJSObjectReference> ITSRuntime.GetTestModuleModule() => GetTestModuleModule();
    private Task<IJSObjectReference>? TestModuleModule;
    private Task<IJSObjectReference> GetTestModuleModule()
        => TestModuleModule switch {
            Task<IJSObjectReference> { IsCompletedSuccessfully: true }
            or Task<IJSObjectReference> { IsCompleted: false } => TestModuleModule,
            _ => TestModuleModule = jsRuntime.InvokeAsync<IJSObjectReference>("import", cancellationTokenSource.Token, "/TestModule.js").AsTask()
        };

    Task<IJSObjectReference> ITSRuntime.GetNestedTestModuleModule() => GetNestedTestModuleModule();
    private Task<IJSObjectReference>? NestedTestModuleModule;
    private Task<IJSObjectReference> GetNestedTestModuleModule()
        => NestedTestModuleModule switch {
            Task<IJSObjectReference> { IsCompletedSuccessfully: true }
            or Task<IJSObjectReference> { IsCompleted: false } => NestedTestModuleModule,
            _ => NestedTestModuleModule = jsRuntime.InvokeAsync<IJSObjectReference>("import", cancellationTokenSource.Token, "/NestedFolder/NestedTestModule.js").AsTask()
        };

    public Task PreloadAllModules() {
        GetTestModuleModule();
        GetNestedTestModuleModule();

        return Task.WhenAll([TestModuleModule!, NestedTestModuleModule!]);
    }


    /// <summary>
    /// Releases each module synchronously if possible, otherwise asynchronously per fire and forget.
    /// </summary>
    public void Dispose() {
        if (cancellationTokenSource.IsCancellationRequested)
            return;

        cancellationTokenSource.Cancel();
        cancellationTokenSource.Dispose();

        if (TestModuleModule?.IsCompletedSuccessfully == true)
            if (TestModuleModule.Result is IJSInProcessObjectReference inProcessModule)
                inProcessModule.Dispose();
            else
                _ = TestModuleModule.Result.DisposeAsync().Preserve();
        TestModuleModule = null;

        if (NestedTestModuleModule?.IsCompletedSuccessfully == true)
            if (NestedTestModuleModule.Result is IJSInProcessObjectReference inProcessModule)
                inProcessModule.Dispose();
            else
                _ = NestedTestModuleModule.Result.DisposeAsync().Preserve();
        NestedTestModuleModule = null;
    }

    /// <summary>
    /// <para>Releases each module synchronously if possible, otherwise asynchronously and returns a task that completes, when all module disposing tasks complete.</para>
    /// <para>The asynchronous disposing tasks are happening in parallel.</para>
    /// </summary>
    /// <returns></returns>
    public ValueTask DisposeAsync() {
        if (cancellationTokenSource.IsCancellationRequested)
            return ValueTask.CompletedTask;

        cancellationTokenSource.Cancel();
        cancellationTokenSource.Dispose();

        List<Task> taskList = new(2);

        if (TestModuleModule?.IsCompletedSuccessfully == true)
            if (TestModuleModule.Result is IJSInProcessObjectReference inProcessModule)
                inProcessModule.Dispose();
            else {
                ValueTask valueTask = TestModuleModule.Result.DisposeAsync();
                if (!valueTask.IsCompleted)
                    taskList.Add(valueTask.AsTask());
            }
        TestModuleModule = null;

        if (NestedTestModuleModule?.IsCompletedSuccessfully == true)
            if (NestedTestModuleModule.Result is IJSInProcessObjectReference inProcessModule)
                inProcessModule.Dispose();
            else {
                ValueTask valueTask = NestedTestModuleModule.Result.DisposeAsync();
                if (!valueTask.IsCompleted)
                    taskList.Add(valueTask.AsTask());
            }
        NestedTestModuleModule = null;

        if (taskList.Count == 0)
            return ValueTask.CompletedTask;
        else
            return new ValueTask(Task.WhenAll(taskList));
    }
}


----------
ITSRuntime
----------

// <auto-generated/>
#pragma warning disable
#nullable enable annotations


using System.Threading;
using System.Threading.Tasks;

namespace Microsoft.JSInterop;

/// <summary>
/// <para>Interface for JS-interop.</para>
/// <para>It contains an invoke-method for every js-function, a preload-method for every module and a method to load all modules.</para>
/// </summary>
[System.CodeDom.Compiler.GeneratedCodeAttribute("Blazor.TSRuntime", "0.6.0")]
public partial interface ITSRuntime {
    /// <summary>
    /// <para>Fetches all modules as javascript-modules.</para>
    /// <para>If already loading, it doesn't trigger a second loading and if any already loaded, these are not loaded again, so if all already loaded, it returns a completed task.</para>
    /// </summary>
    /// <returns>A Task that will complete when all module loading Tasks have completed.</returns>
    public Task PreloadAllModules();
    

    /// <summary>
    /// <para>Invokes the specified JavaScript function in the specified module synchronously.</para>
    /// <para>If module is not loaded, it returns without any invoking. If synchronous is not supported, it fails with an exception.</para>
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="moduleUrl">complete path of the module, e.g. "/Pages/Example.razor.js"</param>
    /// <param name="identifier">name of the javascript function</param>
    /// <param name="success">false when the module is not loaded, otherwise true</param>
    /// <param name="args">parameter passing to the JS-function</param>
    /// <returns>default when the module is not loaded, otherwise result of the JS-function</returns>
    private TResult Invoke<TResult>(Task<IJSObjectReference> moduleTask, string identifier, params object?[]? args) {
        if (!moduleTask.IsCompletedSuccessfully)
            throw new JSException("JS-module is not loaded. Use and await the Preload-method to ensure the module is loaded.");

        return ((IJSInProcessObjectReference)moduleTask.Result).Invoke<TResult>(identifier, args);
    }

    /// <summary>
    /// Invokes the specified JavaScript function in the specified module synchronously when supported, otherwise asynchronously.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="moduleUrl">complete path of the module, e.g. "/Pages/Example.razor.js"</param>
    /// <param name="identifier">name of the javascript function</param>
    /// <param name="cancellationToken">A cancellation token to signal the cancellation of the operation. Specifying this parameter will override any default cancellations such as due to timeouts (<see cref="JSRuntime.DefaultAsyncTimeout"/>) from being applied.</param>
    /// <param name="args">parameter passing to the JS-function</param>
    /// <returns></returns>
    private async ValueTask<TValue> InvokeTrySync<TValue>(Task<IJSObjectReference> moduleTask, string identifier, CancellationToken cancellationToken, params object?[]? args) {
        IJSObjectReference module = await moduleTask;
        if (module is IJSInProcessObjectReference inProcessModule)
            return inProcessModule.Invoke<TValue>(identifier, args);
        else
            return await module.InvokeAsync<TValue>(identifier, cancellationToken, args);
    }

    /// <summary>
    /// Invokes the specified JavaScript function in the specified module asynchronously.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="moduleUrl">complete path of the module, e.g. "/Pages/Example.razor.js"</param>
    /// <param name="identifier">name of the javascript function</param>
    /// <param name="cancellationToken">A cancellation token to signal the cancellation of the operation. Specifying this parameter will override any default cancellations such as due to timeouts (<see cref="JSRuntime.DefaultAsyncTimeout"/>) from being applied.</param>
    /// <param name="args">parameter passing to the JS-function</param>
    /// <returns></returns>
    private async ValueTask<TValue> InvokeAsync<TValue>(Task<IJSObjectReference> moduleTask, string identifier, CancellationToken cancellationToken, params object?[]? args) {
        IJSObjectReference module = await moduleTask;
        return await module.InvokeAsync<TValue>(identifier, cancellationToken, args);
    }
}


------
Module
------

// <auto-generated/>
#pragma warning disable
#nullable enable annotations


using System.Threading;
using System.Threading.Tasks;

namespace Microsoft.JSInterop;

public partial interface ITSRuntime {
    protected Task<IJSObjectReference> GetTestModuleModule();

    /// <summary>
    /// <para>Loads 'TestModule' (/TestModule.js) as javascript-module.</para>
    /// <para>If already loading, it does not trigger a second loading and if already loaded, it returns a completed task.</para>
    /// </summary>
    /// <returns>A Task that will complete when the module import have completed.</returns>
    public Task PreloadTestModule() => GetTestModuleModule();

}


-------------
Nested Module
-------------

// <auto-generated/>
#pragma warning disable
#nullable enable annotations


using System.Threading;
using System.Threading.Tasks;

namespace Microsoft.JSInterop;

public partial interface ITSRuntime {
    protected Task<IJSObjectReference> GetNestedTestModuleModule();

    /// <summary>
    /// <para>Loads 'NestedTestModule' (/NestedFolder/NestedTestModule.js) as javascript-module.</para>
    /// <para>If already loading, it does not trigger a second loading and if already loaded, it returns a completed task.</para>
    /// </summary>
    /// <returns>A Task that will complete when the module import have completed.</returns>
    public Task PreloadNestedTestModule() => GetNestedTestModuleModule();

}
