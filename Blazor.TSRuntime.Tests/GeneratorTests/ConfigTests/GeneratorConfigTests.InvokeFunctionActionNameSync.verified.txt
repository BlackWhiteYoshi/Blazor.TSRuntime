---------
TSRuntime
---------

// <auto-generated/>
#pragma warning disable
#nullable enable annotations


using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;

namespace Microsoft.JSInterop;

/// <summary>
/// <para>An implementation for <see cref="ITSRuntime"/>.</para>
/// <para>It manages JS-modules: It loads the modules, caches it in an array and disposing releases all modules.</para>
/// <para>
/// There are 2 modules available:<br />
/// - TestModule<br />
/// - NestedTestModule
/// </para>
/// </summary>
[System.CodeDom.Compiler.GeneratedCodeAttribute("Blazor.TSRuntime", "0.7.0")]
public sealed class TSRuntime(IJSRuntime jsRuntime) : ITSRuntime, IDisposable, IAsyncDisposable {
    private readonly CancellationTokenSource cancellationTokenSource = new();

    Task<IJSObjectReference> ITSRuntime.GetTestModuleModule() => GetTestModuleModule();
    private Task<IJSObjectReference>? TestModuleModule;
    private Task<IJSObjectReference> GetTestModuleModule()
        => TestModuleModule switch {
            Task<IJSObjectReference> { IsCompletedSuccessfully: true }
            or Task<IJSObjectReference> { IsCompleted: false } => TestModuleModule,
            _ => TestModuleModule = jsRuntime.InvokeAsync<IJSObjectReference>("import", cancellationTokenSource.Token, "/TestModule.js").AsTask()
        };

    Task<IJSObjectReference> ITSRuntime.GetNestedTestModuleModule() => GetNestedTestModuleModule();
    private Task<IJSObjectReference>? NestedTestModuleModule;
    private Task<IJSObjectReference> GetNestedTestModuleModule()
        => NestedTestModuleModule switch {
            Task<IJSObjectReference> { IsCompletedSuccessfully: true }
            or Task<IJSObjectReference> { IsCompleted: false } => NestedTestModuleModule,
            _ => NestedTestModuleModule = jsRuntime.InvokeAsync<IJSObjectReference>("import", cancellationTokenSource.Token, "/NestedFolder/NestedTestModule.js").AsTask()
        };

    public Task PreloadAllModules() {
        GetTestModuleModule();
        GetNestedTestModuleModule();

        return Task.WhenAll([TestModuleModule!, NestedTestModuleModule!]);
    }


    TResult ITSRuntime.TSInvoke<TResult>(string identifier, object?[]? args) => ((IJSInProcessRuntime)jsRuntime).Invoke<TResult>(identifier, args);

    ValueTask<TValue> ITSRuntime.TSInvokeTrySync<TValue>(string identifier, object?[]? args, CancellationToken cancellationToken) {
        if (jsRuntime is IJSInProcessRuntime jsInProcessRuntime)
            return ValueTask.FromResult(jsInProcessRuntime.Invoke<TValue>(identifier, args));
        else
            return jsRuntime.InvokeAsync<TValue>(identifier, cancellationToken, args);
    }

    ValueTask<TValue> ITSRuntime.TSInvokeAsync<TValue>(string identifier, object?[]? args, CancellationToken cancellationToken)
        => jsRuntime.InvokeAsync<TValue>(identifier, cancellationToken, args);


    /// <summary>
    /// Releases each module synchronously if possible, otherwise asynchronously per fire and forget.
    /// </summary>
    public void Dispose() {
        if (cancellationTokenSource.IsCancellationRequested)
            return;

        cancellationTokenSource.Cancel();
        cancellationTokenSource.Dispose();

        if (TestModuleModule?.IsCompletedSuccessfully == true)
            if (TestModuleModule.Result is IJSInProcessObjectReference inProcessModule)
                inProcessModule.Dispose();
            else
                _ = TestModuleModule.Result.DisposeAsync().Preserve();
        TestModuleModule = null;

        if (NestedTestModuleModule?.IsCompletedSuccessfully == true)
            if (NestedTestModuleModule.Result is IJSInProcessObjectReference inProcessModule)
                inProcessModule.Dispose();
            else
                _ = NestedTestModuleModule.Result.DisposeAsync().Preserve();
        NestedTestModuleModule = null;
    }

    /// <summary>
    /// <para>Releases each module synchronously if possible, otherwise asynchronously and returns a task that completes, when all module disposing tasks complete.</para>
    /// <para>The asynchronous disposing tasks are happening in parallel.</para>
    /// </summary>
    /// <returns></returns>
    public ValueTask DisposeAsync() {
        if (cancellationTokenSource.IsCancellationRequested)
            return ValueTask.CompletedTask;

        cancellationTokenSource.Cancel();
        cancellationTokenSource.Dispose();

        List<Task> taskList = new(2);

        if (TestModuleModule?.IsCompletedSuccessfully == true)
            if (TestModuleModule.Result is IJSInProcessObjectReference inProcessModule)
                inProcessModule.Dispose();
            else {
                ValueTask valueTask = TestModuleModule.Result.DisposeAsync();
                if (!valueTask.IsCompleted)
                    taskList.Add(valueTask.AsTask());
            }
        TestModuleModule = null;

        if (NestedTestModuleModule?.IsCompletedSuccessfully == true)
            if (NestedTestModuleModule.Result is IJSInProcessObjectReference inProcessModule)
                inProcessModule.Dispose();
            else {
                ValueTask valueTask = NestedTestModuleModule.Result.DisposeAsync();
                if (!valueTask.IsCompleted)
                    taskList.Add(valueTask.AsTask());
            }
        NestedTestModuleModule = null;

        if (taskList.Count == 0)
            return ValueTask.CompletedTask;
        else
            return new ValueTask(Task.WhenAll(taskList));
    }
}


----------
ITSRuntime
----------

// <auto-generated/>
#pragma warning disable
#nullable enable annotations


using System.Threading;
using System.Threading.Tasks;

namespace Microsoft.JSInterop;

/// <summary>
/// <para>Interface for JS-interop.</para>
/// <para>It contains an invoke-method for every js-function, a preload-method for every module and a method to load all modules.</para>
/// </summary>
[System.CodeDom.Compiler.GeneratedCodeAttribute("Blazor.TSRuntime", "0.7.0")]
public partial interface ITSRuntime {
    /// <summary>
    /// <para>Fetches all modules as javascript-modules.</para>
    /// <para>If already loading, it doesn't trigger a second loading and if any already loaded, these are not loaded again, so if all already loaded, it returns a completed task.</para>
    /// </summary>
    /// <returns>A Task that will complete when all module loading Tasks have completed.</returns>
    public Task PreloadAllModules();
    

    /// <summary>
    /// <para>Invokes the specified JavaScript function synchronously.</para>
    /// </summary>
    /// <typeparam name="TResult"></typeparam>
    /// <param name="identifier">name of the javascript function</param>
    /// <param name="args">parameter passing to the JS-function</param>
    /// <returns></returns>
    protected TResult TSInvoke<TResult>(string identifier, object?[]? args);

    /// <summary>
    /// Invokes the specified JavaScript function synchronously when supported, otherwise asynchronously.
    /// </summary>
    /// <typeparam name="TValue"></typeparam>
    /// <param name="identifier">name of the javascript function</param>
    /// <param name="args">parameter passing to the JS-function</param>
    /// <param name="cancellationToken">A cancellation token to signal the cancellation of the operation. Specifying this parameter will override any default cancellations such as due to timeouts (<see cref="JSRuntime.DefaultAsyncTimeout"/>) from being applied.</param>
    /// <returns></returns>
    protected ValueTask<TValue> TSInvokeTrySync<TValue>(string identifier, object?[]? args, CancellationToken cancellationToken);

    /// <summary>
    /// Invokes the specified JavaScript function asynchronously.
    /// </summary>
    /// <typeparam name="TValue"></typeparam>
    /// <param name="identifier">name of the javascript function</param>
    /// <param name="args">parameter passing to the JS-function</param>
    /// <param name="cancellationToken">A cancellation token to signal the cancellation of the operation. Specifying this parameter will override any default cancellations such as due to timeouts (<see cref="JSRuntime.DefaultAsyncTimeout"/>) from being applied.</param>
    /// <returns></returns>
    protected ValueTask<TValue> TSInvokeAsync<TValue>(string identifier, object?[]? args, CancellationToken cancellationToken);

    /// <summary>
    /// <para>Invokes the specified JavaScript function in the specified module synchronously.</para>
    /// <para>If module is not loaded, it returns without any invoking. If synchronous is not supported, it fails with an exception.</para>
    /// </summary>
    /// <typeparam name="TResult"></typeparam>
    /// <param name="moduleTask">The loading task of a module</param>
    /// <param name="identifier">name of the javascript function</param>
    /// <param name="args">parameter passing to the JS-function</param>
    /// <returns></returns>
    private TResult TSInvoke<TResult>(Task<IJSObjectReference> moduleTask, string identifier, object?[]? args) {
        if (!moduleTask.IsCompletedSuccessfully)
            throw new JSException("JS-module is not loaded. Use and await the Preload-method to ensure the module is loaded.");

        return ((IJSInProcessObjectReference)moduleTask.Result).Invoke<TResult>(identifier, args);
    }

    /// <summary>
    /// Invokes the specified JavaScript function in the specified module synchronously when supported, otherwise asynchronously.
    /// </summary>
    /// <typeparam name="TValue"></typeparam>
    /// <param name="moduleTask">The loading task of a module</param>
    /// <param name="identifier">name of the javascript function</param>
    /// <param name="args">parameter passing to the JS-function</param>
    /// <param name="cancellationToken">A cancellation token to signal the cancellation of the operation. Specifying this parameter will override any default cancellations such as due to timeouts (<see cref="JSRuntime.DefaultAsyncTimeout"/>) from being applied.</param>
    /// <returns></returns>
    private async ValueTask<TValue> TSInvokeTrySync<TValue>(Task<IJSObjectReference> moduleTask, string identifier, object?[]? args, CancellationToken cancellationToken) {
        IJSObjectReference module = await moduleTask;
        if (module is IJSInProcessObjectReference inProcessModule)
            return inProcessModule.Invoke<TValue>(identifier, args);
        else
            return await module.InvokeAsync<TValue>(identifier, cancellationToken, args);
    }

    /// <summary>
    /// Invokes the specified JavaScript function in the specified module asynchronously.
    /// </summary>
    /// <typeparam name="TValue"></typeparam>
    /// <param name="moduleTask">The loading task of a module</param>
    /// <param name="identifier">name of the javascript function</param>
    /// <param name="args">parameter passing to the JS-function</param>
    /// <param name="cancellationToken">A cancellation token to signal the cancellation of the operation. Specifying this parameter will override any default cancellations such as due to timeouts (<see cref="JSRuntime.DefaultAsyncTimeout"/>) from being applied.</param>
    /// <returns></returns>
    private async ValueTask<TValue> TSInvokeAsync<TValue>(Task<IJSObjectReference> moduleTask, string identifier, object?[]? args, CancellationToken cancellationToken) {
        IJSObjectReference module = await moduleTask;
        return await module.InvokeAsync<TValue>(identifier, cancellationToken, args);
    }
}


------
Module
------

// <auto-generated/>
#pragma warning disable
#nullable enable annotations


using System.Threading;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Components;
using System.Numerics;

namespace Microsoft.JSInterop;

public partial interface ITSRuntime {
    protected Task<IJSObjectReference> GetTestModuleModule();

    /// <summary>
    /// <para>Loads 'TestModule' (/TestModule.js) as javascript-module.</para>
    /// <para>If already loading, it does not trigger a second loading and if already loaded, it returns a completed task.</para>
    /// </summary>
    /// <returns>A Task that will complete when the module import have completed.</returns>
    public Task PreloadTestModule() => GetTestModuleModule();


    /// <summary>
    /// <para>Invokes in module 'TestModule' the JS-function 'Test' synchronously.</para>
    /// <para>If module is not loaded or synchronous is not supported, it fails with an exception.</para>
    /// </summary>
    /// <typeparam name="TNumber"></typeparam>
    /// <param name="a"></param>
    /// <param name="b"></param>
    /// <returns>Result of the JS-function.</returns>
    public TNumber TestModule_Test_TTT<TNumber>(TNumber a, string b) where TNumber : INumber<TNumber>
        => TSInvoke<TNumber>(GetTestModuleModule(), "Test", [a, b]);

    /// <summary>
    /// <para>Invokes in module 'TestModule' the JS-function 'Test' synchronously when supported, otherwise asynchronously.</para>
    /// </summary>
    /// <typeparam name="TNumber"></typeparam>
    /// <param name="a"></param>
    /// <param name="b"></param>
    /// <param name="cancellationToken">A cancellation token to signal the cancellation of the operation. Specifying this parameter will override any default cancellations such as due to timeouts (<see cref="JSRuntime.DefaultAsyncTimeout"/>) from being applied.</param>
    /// <returns>Result of the JS-function.</returns>
    public ValueTask<TNumber> TestModule_Test_InvokeTrySync<TNumber>(TNumber a, string b, CancellationToken cancellationToken = default) where TNumber : INumber<TNumber>
        => TSInvokeTrySync<TNumber>(GetTestModuleModule(), "Test", [a, b], cancellationToken);
}


-------------
Nested Module
-------------

// <auto-generated/>
#pragma warning disable
#nullable enable annotations


using System.Threading;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Components;
using System.Numerics;

namespace Microsoft.JSInterop;

public partial interface ITSRuntime {
    protected Task<IJSObjectReference> GetNestedTestModuleModule();

    /// <summary>
    /// <para>Loads 'NestedTestModule' (/NestedFolder/NestedTestModule.js) as javascript-module.</para>
    /// <para>If already loading, it does not trigger a second loading and if already loaded, it returns a completed task.</para>
    /// </summary>
    /// <returns>A Task that will complete when the module import have completed.</returns>
    public Task PreloadNestedTestModule() => GetNestedTestModuleModule();


    /// <summary>
    /// <para>Invokes in module 'NestedTestModule' the JS-function 'NestedTest' asynchronously.</para>
    /// </summary>
    /// <param name="cancellationToken">A cancellation token to signal the cancellation of the operation. Specifying this parameter will override any default cancellations such as due to timeouts (<see cref="JSRuntime.DefaultAsyncTimeout"/>) from being applied.</param>
    /// <returns>A Task that will complete when the JS-Function have completed.</returns>
    public Task NestedTestModule_NestedTest_InvokeAsync(CancellationToken cancellationToken = default)
        => TSInvokeAsync<Infrastructure.IJSVoidResult>(GetNestedTestModuleModule(), "NestedTest", [], cancellationToken) switch {
            ValueTask<Infrastructure.IJSVoidResult> { IsCompleted: true } => Task.CompletedTask,
            ValueTask<Infrastructure.IJSVoidResult> task => task.AsTask()
        };
}


----------------
ServiceExtension
----------------

// <auto-generated/>
#pragma warning disable
#nullable enable annotations


using Microsoft.Extensions.DependencyInjection;

namespace Microsoft.JSInterop;

public static class TSRuntimeServiceExtension {
    /// <summary>
    /// Registers a scoped ITSRuntime with a TSRuntime as implementation and if available, registers the module interfaces with the same TSRuntime-object.
    /// </summary>
    /// <param name="services"></param>
    /// <returns></returns>
    public static IServiceCollection AddTSRuntime(this IServiceCollection services) {
        services.AddScoped<ITSRuntime, TSRuntime>();

        return services;
    }
}
