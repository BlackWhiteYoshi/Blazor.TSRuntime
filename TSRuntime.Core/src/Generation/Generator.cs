using TSRuntime.Core.Configs;
using TSRuntime.Core.Parsing;

namespace TSRuntime.Core.Generation;

/// <summary>
/// Contains the 2 functions for generating the content for the class "TSRuntime" and the interface "ITSRuntime".
/// </summary>
public static partial class Generator {
    /// <summary>
    /// <para>The content for the TSRuntime file.</para>
    /// <para>It returns a constant string, so class TSRuntime is always the same.</para>
    /// </summary>
    public static string TSRuntimeContent => """
        // <auto-generated>
        #pragma warning disable
        #nullable enable annotations


        using System.Threading;
        using System.Threading.Tasks;

        namespace Microsoft.JSInterop;

        public sealed class TSRuntime : ITSRuntime, IDisposable, IAsyncDisposable
        {
            #region construction

            private readonly IJSRuntime _jsRuntime;
            IJSRuntime ITSRuntime.JsRuntime => _jsRuntime;


            public TSRuntime(IJSRuntime jsRuntime)
            {
                _jsRuntime = jsRuntime;
            }

            #endregion


            #region disposing

            private readonly CancellationTokenSource cancellationTokenSource = new();

            public void Dispose()
            {
                cancellationTokenSource.Cancel();
                cancellationTokenSource.Dispose();

                for (int i = 0; i < modules.Length; i++)
                {
                    Task<IJSObjectReference>? module = modules[i];

                    if (module?.IsCompletedSuccessfully == true)
                        _ = module.Result.DisposeAsync().Preserve();

                    modules[i] = null;
                }
            }

            public ValueTask DisposeAsync()
            {
                cancellationTokenSource.Cancel();
                cancellationTokenSource.Dispose();

                List<Task> taskList = new();
                for (int i = 0; i < modules.Length; i++)
                {
                    Task<IJSObjectReference>? module = modules[i];

                    if (module?.IsCompletedSuccessfully == true)
                    {
                        ValueTask valueTask = module.Result.DisposeAsync();
                        if (!valueTask.IsCompleted)
                            taskList.Add(valueTask.AsTask());
                    }

                    modules[i] = null;
                }

                if (taskList.Count == 0)
                    return ValueTask.CompletedTask;
                else
                    return new ValueTask(Task.WhenAll(taskList));
            }

            #endregion


            #region moduleList

            private readonly Task<IJSObjectReference>?[] modules = new Task<IJSObjectReference>?[ITSRuntime.MODULE_COUNT];
            Task<IJSObjectReference>?[] ITSRuntime.Modules => modules;

            Task<IJSObjectReference> ITSRuntime.GetOrLoadModule(int index, string url) {
                if (modules[index]?.IsCompletedSuccessfully == true)
                    return modules[index]!;

                return modules[index] = _jsRuntime.InvokeAsync<IJSObjectReference>("import", cancellationTokenSource.Token, url).AsTask();
            }

            #endregion
        }
        
        """;

    /// <summary>
    /// <para>Creates the content of the interface "ITSRuntime" based on the given <see cref="TSStructureTree">structureTree</see> and <see cref="Config">config</see>.</para>
    /// <para>To avoid string allocations/concationations, the content is delivered as a stream of strings.</para>
    /// <para>This method is source-generated.</para>
    /// </summary>
    /// <param name="structureTree"></param>
    /// <param name="config"></param>
    /// <returns></returns>
    public static partial IEnumerable<string> GetITSRuntimeContent(TSStructureTree structureTree, Config config);


    /// <summary>
    /// <para>Creates a parameter list, an argument list and the mapped return type that can be used to create generated code.</para>
    /// <para>Used by the SourceGenerator.</para>
    /// </summary>
    /// <param name="typeMap"></param>
    /// <param name="function"></param>
    /// <returns></returns>
    private static (List<string> parameters, List<string> arguments, string returnType) CreateParamterList(this Dictionary<string, string> typeMap, TSFunction function) {
        List<string> parameters = new(function.ParameterList.Count * 4);
        List<string> arguments = new(function.ParameterList.Count * 2);

        foreach (TSParameter parameter in function.ParameterList) {
            string mappedType = GetValueOrKey(typeMap, parameter.Type);

            parameters.Add(mappedType);
            if (parameter.TypeNullable)
                parameters.Add("?");
            if (parameter.Array)
                parameters.Add("[]");
            if (parameter.ArrayNullable)
                parameters.Add("?");
            parameters.Add(" ");
            parameters.Add(parameter.Name);
            parameters.Add(", ");

            arguments.Add(", ");
            arguments.Add(parameter.Name);
        }

        TSParameter tsReturnType = function.ReturnType;
        string rawReturnType = GetValueOrKey(typeMap, tsReturnType.Type);
        string returnType = (tsReturnType.TypeNullable, tsReturnType.Array, tsReturnType.ArrayNullable) switch {
            (false, false, _) => rawReturnType,
            (true, false, _) => $"{rawReturnType}?",
            (false, true, false) => $"{rawReturnType}[]",
            (false, true, true) => $"{rawReturnType}[]?",
            (true, true, false) => $"{rawReturnType}?[]",
            (true, true, true) => $"{rawReturnType}?[]?"
        };

        return (parameters, arguments, returnType);


        /// Retrieves the value in a Dictionary and defaults to the given key if not found.
        static string GetValueOrKey(Dictionary<string, string> dictionary, string key) {
            bool success = dictionary.TryGetValue(key, out string? value);
            if (success)
                return value!;
            else
                return key;
        }
    }
}
