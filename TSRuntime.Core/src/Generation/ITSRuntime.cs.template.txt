///
/// pseudo syntax for documentation purpose only
///
/// '#if', '#endif' or '#foreach', '#end foreach' means if-condition or loop
/// '《variable》' means interpolation of a variable
///
/// '《function.ReturnType(MappedIJSVoidResult)》' means if (mappedReturnType == void) { "IJSVoidResult" } else { mappedReturnType }
/// '《function.ReturnType(MappedValueTask)》' means if (mappedReturnType == void) { string.empty } else { <mappedReturnType> }
///



#foreach usingStatement in config.UsingStatements
using 《usingStatement》;
#end foreach
using Microsoft.JSInterop.Infrastructure;
using System.Diagnostics.CodeAnalysis;
using System.Threading;
using System.Threading.Tasks;

namespace Microsoft.JSInterop;

public interface ITSRuntime {
    protected const int MODULE_COUNT = 《ModuleList.Count》;
    
    protected IJSRuntime JsRuntime { get; }


    #foreach module
    /// <summary>
    /// <para>Preloads 《module.ModuleName》 (《module.ModulePath》) as javascript-module.</para>
    /// <para>If already loading, it doesn't trigger a second loading and if already loaded, it returns a completed task.</para>
    /// </summary>
    public async ValueTask Preload《module.Name》()
        => await GetOrLoadModule(《ModuleList.index》, "《module.ModulePath》");
    
    #end foreach

    protected Task<IJSObjectReference> GetOrLoadModule(int index, string url);


    #region module methods

    #foreach module
    #foreach function
    
    #if not function.Promise
    
    /// <summary>
    /// <para>Invokes in module 《module.ModuleName》 the js-function 《function.Name》 synchronously.</para>
    /// <para>If module is not loaded, it returns without any invoking. If synchronous is not supported, it fails with an exception.</para>
    /// </summary>
    #foreach parameter
    /// <param name="《parameter.Name》"></param>
    #end foreach
    /// <returns>default when the module is not loaded, otherwise result of the js-function</returns>
    public 《function.ReturnType(Mapped)》 Invoke_《module.Name》_《function.Name》(《..parameters》)
        => Invoke<《function.ReturnType(MappedIJSVoidResult)》>(index, "《module.Path》", "《function.Name》", out _, 《..arguments》);
    
    /// <summary>
    /// <para>Invokes in module 《module.Name》 the js-function 《function.Name》 synchronously.</para>
    /// <para>If module is not loaded, it returns without any invoking. If synchronous is not supported, it fails with an exception.</para>
    /// </summary>
    #foreach parameter
    /// <param name="《parameter.Name》"></param>
    #end foreach
    /// <param name="success">false when the module is not loaded, otherwise true</param>
    /// <returns>default when the module is not loaded, otherwise result of the js-function</returns>
    public 《function.ReturnType(Mapped)》 Invoke_《module.Name》_《function.Name》(《..parameters》, out bool success)
        => Invoke<《function.ReturnType(MappedIJSVoidResult)》>(index, "《module.Path》", "《function.Name》", out success, 《..arguments》);
    
    /// <summary>
    /// Invokes in module 《module.Name》 the js-function 《function.Name》 synchronously when supported, otherwise asynchronously.
    /// </summary>
    #foreach parameter
    /// <param name="《parameter.Name》"></param>
    #end foreach
    /// <param name="cancellationToken">A cancellation token to signal the cancellation of the operation. Specifying this parameter will override any default cancellations such as due to timeouts (<see cref="JSRuntime.DefaultAsyncTimeout"/>) from being applied.</param>
    /// <returns></returns>
    public 《async》 ValueTask《function.ReturnType(MappedValueTask)》 InvokeTrySync_《module.Name》_《function.Name》(《..parameters》, CancellationToken cancellationToken = default)
        => 《await》 InvokeTrySync<《function.ReturnType(MappedIJSVoidResult)》>(index, "《module.Path》", "《function.Name》", cancellationToken, 《..arguments》);
    
    #endif
    
    /// <summary>
    /// Invokes in module 《module.Name》 the js-function 《function.Name》 asynchronously.
    /// </summary>
    #foreach parameter
    /// <param name="《parameter.Name》"></param>
    #end foreach
    /// <param name="cancellationToken">A cancellation token to signal the cancellation of the operation. Specifying this parameter will override any default cancellations such as due to timeouts (<see cref="JSRuntime.DefaultAsyncTimeout"/>) from being applied.</param>
    /// <returns></returns>
    public 《async》 ValueTask《function.ReturnType(MappedValueTask)》 InvokeAsync_《module.Name》_《function.Name》(《..parameters》, CancellationToken cancellationToken = default)
        => 《await》 InvokeAsync<《function.ReturnType(MappedIJSVoidResult)》>(index, "《module.Path》", "《function.Name》", cancellationToken, 《..arguments》);
    
    #end foreach
    #end foreach



    /// <summary>
    /// <para>Invokes the specified JavaScript function in the specified module synchronously.</para>
    /// <para>If module is not loaded, it returns without any invoking. If synchronous is not supported, it fails with an exception.</para>
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="moduleUrl">complete path of the module, e.g. "/Pages/Example.razor.js"</param>
    /// <param name="identifier">name of the javascript function</param>
    /// <param name="success">false when the module is not loaded, otherwise true</param>
    /// <param name="args">parameter passing to the js-function</param>
    /// <returns>default when the module is not loaded, otherwise result of the js-function</returns>
    private TResult Invoke<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicConstructors | DynamicallyAccessedMemberTypes.PublicFields | DynamicallyAccessedMemberTypes.PublicProperties)] TResult>(int moduleIndex, string moduleUrl, string identifier, out bool success, params object?[]? args) {
        Task<IJSObjectReference> moduleTask = GetOrLoadModule(moduleIndex, moduleUrl);
        if (!moduleTask.IsCompletedSuccessfully) {
            success = false;
            return default!;
        }

        success = true;
        return ((IJSInProcessObjectReference)moduleTask.Result).Invoke<TResult>(identifier, args);
    }

    /// <summary>
    /// Invokes the specified JavaScript function in the specified module synchronously when supported, otherwise asynchronously.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="moduleUrl">complete path of the module, e.g. "/Pages/Example.razor.js"</param>
    /// <param name="identifier">name of the javascript function</param>
    /// <param name="cancellationToken">A cancellation token to signal the cancellation of the operation. Specifying this parameter will override any default cancellations such as due to timeouts (<see cref="JSRuntime.DefaultAsyncTimeout"/>) from being applied.</param>
    /// <param name="args">parameter passing to the js-function</param>
    /// <returns></returns>
    private async ValueTask<TValue> InvokeTrySync<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicConstructors | DynamicallyAccessedMemberTypes.PublicFields | DynamicallyAccessedMemberTypes.PublicProperties)] TValue>(int moduleIndex, string moduleUrl, string identifier, CancellationToken cancellationToken, params object?[]? args) {
        IJSObjectReference module = await GetOrLoadModule(moduleIndex, moduleUrl);
        if (module is IJSInProcessObjectReference inProcessModule)
            return inProcessModule.Invoke<TValue>(identifier, args);
        else
            return await module.InvokeAsync<TValue>(identifier, cancellationToken, args);
    }

    /// <summary>
    /// Invokes the specified JavaScript function in the specified module asynchronously.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="moduleUrl">complete path of the module, e.g. "/Pages/Example.razor.js"</param>
    /// <param name="identifier">name of the javascript function</param>
    /// <param name="cancellationToken">A cancellation token to signal the cancellation of the operation. Specifying this parameter will override any default cancellations such as due to timeouts (<see cref="JSRuntime.DefaultAsyncTimeout"/>) from being applied.</param>
    /// <param name="args">parameter passing to the js-function</param>
    /// <returns></returns>
    private async ValueTask<TValue> InvokeAsync<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicConstructors | DynamicallyAccessedMemberTypes.PublicFields | DynamicallyAccessedMemberTypes.PublicProperties)] TValue>(int moduleIndex, string moduleUrl, string identifier, CancellationToken cancellationToken, params object?[]? args) {
        IJSObjectReference module = await GetOrLoadModule(moduleIndex, moduleUrl);
        return await module.InvokeAsync<TValue>(identifier, cancellationToken, args);
    }

    #endregion


    #region non-module methods

    /// <summary>
    /// Invokes the specified JavaScript function synchronously.
    /// </summary>
    /// <param name="jsRuntime">The <see cref="IJSInProcessRuntime"/>.</param>
    /// <param name="identifier">An identifier for the function to invoke. For example, the value <c>"someScope.someFunction"</c> will invoke the function <c>window.someScope.someFunction</c>.</param>
    /// <param name="args">JSON-serializable arguments.</param>
    public void InvokeVoid(string identifier, params object?[]? args)
        => Invoke<IJSVoidResult>(identifier, args);

    /// <summary>
    /// Invokes the specified JavaScript function synchronously.
    /// </summary>
    /// <typeparam name="TResult">The JSON-serializable return type.</typeparam>
    /// <param name="identifier">An identifier for the function to invoke. For example, the value <c>"someScope.someFunction"</c> will invoke the function <c>window.someScope.someFunction</c>.</param>
    /// <param name="args">JSON-serializable arguments.</param>
    /// <returns>An instance of <typeparamref name="TResult"/> obtained by JSON-deserializing the return value.</returns>
    public TResult Invoke<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicConstructors | DynamicallyAccessedMemberTypes.PublicFields | DynamicallyAccessedMemberTypes.PublicProperties)] TResult>(string identifier, params object?[]? args)
        => ((IJSInProcessRuntime)JsRuntime).Invoke<TResult>(identifier, args);


    /// <summary>
    /// This method performs synchronous, if the underlying implementation supports synchrounous interoperability.
    /// </summary>
    /// <param name="identifier">An identifier for the function to invoke. For example, the value <c>"someScope.someFunction"</c> will invoke the function <c>window.someScope.someFunction</c>.</param>
    /// <param name="args">JSON-serializable arguments.</param>
    /// <returns></returns>
    public async ValueTask InvokeVoidTrySync(string identifier, params object?[]? args)
        => await InvokeTrySync<IJSVoidResult>(identifier, default, args);

    /// <summary>
    /// This method performs synchronous, if the underlying implementation supports synchrounous interoperability.
    /// </summary>
    /// <param name="identifier">An identifier for the function to invoke. For example, the value <c>"someScope.someFunction"</c> will invoke the function <c>window.someScope.someFunction</c>.</param>
    /// <param name="cancellationToken">A cancellation token to signal the cancellation of the operation. Specifying this parameter will override any default cancellations such as due to timeouts (<see cref="JSRuntime.DefaultAsyncTimeout"/>) from being applied.</param>
    /// <param name="args">JSON-serializable arguments.</param>
    /// <returns></returns>
    public async ValueTask InvokeVoidTrySync(string identifier, CancellationToken cancellationToken, params object?[]? args)
        => await InvokeTrySync<IJSVoidResult>(identifier, cancellationToken, args);

    /// <summary>
    /// This method performs synchronous, if the underlying implementation supports synchrounous interoperability.
    /// </summary>
    /// <typeparam name="TValue">The JSON-serializable return type.</typeparam>
    /// <param name="identifier">An identifier for the function to invoke. For example, the value <c>"someScope.someFunction"</c> will invoke the function <c>window.someScope.someFunction</c>.</param>
    /// <param name="args">JSON-serializable arguments.</param>
    /// <returns>An instance of <typeparamref name="TValue"/> obtained by JSON-deserializing the return value.</returns>
    public ValueTask<TValue> InvokeTrySync<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicConstructors | DynamicallyAccessedMemberTypes.PublicFields | DynamicallyAccessedMemberTypes.PublicProperties)] TValue>(string identifier, params object?[]? args)
        => InvokeTrySync<TValue>(identifier, default, args);

    /// <summary>
    /// This method performs synchronous, if the underlying implementation supports synchrounous interoperability.
    /// </summary>
    /// <typeparam name="TValue">The JSON-serializable return type.</typeparam>
    /// <param name="identifier">An identifier for the function to invoke. For example, the value <c>"someScope.someFunction"</c> will invoke the function <c>window.someScope.someFunction</c>.</param>
    /// <param name="cancellationToken">A cancellation token to signal the cancellation of the operation. Specifying this parameter will override any default cancellations such as due to timeouts (<see cref="JSRuntime.DefaultAsyncTimeout"/>) from being applied.</param>
    /// <param name="args">JSON-serializable arguments.</param>
    /// <returns>An instance of <typeparamref name="TValue"/> obtained by JSON-deserializing the return value.</returns>
    public ValueTask<TValue> InvokeTrySync<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicConstructors | DynamicallyAccessedMemberTypes.PublicFields | DynamicallyAccessedMemberTypes.PublicProperties)] TValue>(string identifier, CancellationToken cancellationToken, params object?[]? args) {
        if (JsRuntime is IJSInProcessRuntime jsInProcessRuntime)
            return ValueTask.FromResult(jsInProcessRuntime.Invoke<TValue>(identifier, args));
        else
            return JsRuntime.InvokeAsync<TValue>(identifier, cancellationToken, args);
    }


    /// <summary>
    /// Invokes the specified JavaScript function asynchronously.
    /// <para>
    /// <see cref="JSRuntime"/> will apply timeouts to this operation based on the value configured in <see cref="JSRuntime.DefaultAsyncTimeout"/>. To dispatch a call with a different timeout, or no timeout,
    /// consider using <see cref="InvokeVoidAsync{TValue}(string, CancellationToken, object[])" />.
    /// </para>
    /// </summary>
    /// <param name="identifier">An identifier for the function to invoke. For example, the value <c>"someScope.someFunction"</c> will invoke the function <c>window.someScope.someFunction</c>.</param>
    /// <param name="args">JSON-serializable arguments.</param>
    /// <returns></returns>
    public async ValueTask InvokeVoidAsync(string identifier, params object?[]? args)
        => await InvokeAsync<IJSVoidResult>(identifier, default, args);

    /// <summary>
    /// Invokes the specified JavaScript function asynchronously.
    /// </summary>
    /// <param name="identifier">An identifier for the function to invoke. For example, the value <c>"someScope.someFunction"</c> will invoke the function <c>window.someScope.someFunction</c>.</param>
    /// <param name="cancellationToken">
    /// A cancellation token to signal the cancellation of the operation. Specifying this parameter will override any default cancellations such as due to timeouts
    /// (<see cref="JSRuntime.DefaultAsyncTimeout"/>) from being applied.
    /// </param>
    /// <param name="args">JSON-serializable arguments.</param>
    /// <returns></returns>
    public async ValueTask InvokeVoidAsync(string identifier, CancellationToken cancellationToken, params object?[]? args)
        => await InvokeAsync<IJSVoidResult>(identifier, cancellationToken, args);

    /// <summary>
    /// Invokes the specified JavaScript function asynchronously.
    /// <para>
    /// <see cref="JSRuntime"/> will apply timeouts to this operation based on the value configured in <see cref="JSRuntime.DefaultAsyncTimeout"/>. To dispatch a call with a different timeout, or no timeout,
    /// consider using <see cref="InvokeAsync{TValue}(string, CancellationToken, object[])" />.
    /// </para>
    /// </summary>
    /// <typeparam name="TValue">The JSON-serializable return type.</typeparam>
    /// <param name="identifier">An identifier for the function to invoke. For example, the value <c>"someScope.someFunction"</c> will invoke the function <c>window.someScope.someFunction</c>.</param>
    /// <param name="args">JSON-serializable arguments.</param>
    /// <returns>An instance of <typeparamref name="TValue"/> obtained by JSON-deserializing the return value.</returns>
    public ValueTask<TValue> InvokeAsync<TValue>(string identifier, params object?[]? args)
        => InvokeAsync<TValue>(identifier, default, args);

    /// <summary>
    /// Invokes the specified JavaScript function asynchronously.
    /// </summary>
    /// <typeparam name="TValue">The JSON-serializable return type.</typeparam>
    /// <param name="identifier">An identifier for the function to invoke. For example, the value <c>"someScope.someFunction"</c> will invoke the function <c>window.someScope.someFunction</c>.</param>
    /// <param name="cancellationToken">
    /// A cancellation token to signal the cancellation of the operation. Specifying this parameter will override any default cancellations such as due to timeouts
    /// (<see cref="JSRuntime.DefaultAsyncTimeout"/>) from being applied.
    /// </param>
    /// <param name="args">JSON-serializable arguments.</param>
    /// <returns>An instance of <typeparamref name="TValue"/> obtained by JSON-deserializing the return value.</returns>
    public ValueTask<TValue> InvokeAsync<TValue>(string identifier, CancellationToken cancellationToken, params object?[]? args)
        => JsRuntime.InvokeAsync<TValue>(identifier, cancellationToken, args);

    #endregion
}
